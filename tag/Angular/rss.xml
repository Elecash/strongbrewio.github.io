<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link></link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>RxJS best practices in Angular</title>
	  <link>//rxjs-best-practices-in-angular/</link>
	  <author></author>
	  <pubDate>2018-01-04T00:00:00+00:00</pubDate>
	  <guid>//rxjs-best-practices-in-angular/</guid>
	  <description><![CDATA[
	     <p>This article is all about the do’s and don’ts when it comes to writing reactive applications with <a href="http://reactivex.io/">RxJS</a> in <a href="https://angular.io/">Angular</a> applications. 
The best practices described in this article are based on personal experiences and can be assumed as personal opinions.</p>

<p>The topics we will tackle in this article are:</p>
<ul>
  <li><a href="#learning-how-to-think-reactive">Learning how to think reactive</a></li>
  <li><a href="#pipeable-operators">Pipeable operators</a></li>
  <li><a href="#ascii-marble-diagrams">ASCII marble diagrams</a></li>
  <li><a href="#using-pure-functions">Using pure functions</a></li>
  <li><a href="#avoiding-memory-leaks">Avoiding memory leaks</a></li>
  <li><a href="#avoiding-nested-subscribes">Avoiding nested subscribes</a></li>
  <li><a href="#avoiding-manual-subscribes-in-Angular">Avoiding manual subscribes in Angular</a></li>
  <li><a href="#dont-pass-streams-to-components-directly">Don’t pass streams to components directly</a></li>
  <li><a href="#dont-pass-streams-to-services">Don’t pass streams to services</a></li>
  <li><a href="#sharing-subscriptions">Sharing subscriptions</a></li>
  <li><a href="#when-to-use-Subjects">When to use Subjects</a></li>
  <li><a href="#cleancode-practices">Clean-code practices</a></li>
  <li><a href="#Angular-embraces-RxJS">Angular embraces RxJS</a></li>
</ul>

<p><strong>Note:</strong>
We will refer to observables as streams in this article.
Since the streams in this article use the <code>$</code>-suffix, a short explanation.
First of all, there is a lot of debate about the <code>$</code>-suffix but I believe this should be a personal preference. 
The reason why I prefer to use it, is because I find it very easy to separate streams from regular objects.
That being said, I would not consider it a best practice, just a personal choice.</p>

<h2 id="learning-how-to-think-reactive">Learning how to think reactive</h2>

<p>Reactive programming is completely different than imperative programming. It requires us to make a certain mind switch.
This mind switch is rather important if we want to benefit from RxJS completely.
We want to <strong>stop thinking in specific actions</strong> and we want to <strong>start thinking in streams</strong>. 
It requires us to forget a part of practices that we already know (at least for a moment).
In <a href="http://blog.brecht.io/Creating-reactive-calendar-in-angular4/">this article</a> we can find some tips and practical examples on how to start thinking reactive in RxJS.</p>

<h2 id="pipeable-operators">Pipeable operators</h2>

<p>The first best practice is the use of pipeable operators. The operators being used in this article are pipeable.
Since version 5.5 RxJS has introduced these so called lettable operators which are easier to import than patch operators, and
also have <a href="https://webpack.js.org/guides/tree-shaking/">treeshaking</a> advantages. More information about lettable operators can be found <a href="https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3">here</a> and <a href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44">here</a>.</p>

<p>This example illustrates the difference between doing it the old way and the new way.</p>

<pre><code class="language-typescript">// BAD: This is the old way and should be avoided (patch operators)
// as we can see the operators (filter, map) are part of the
// Observable prototype
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/map';
const new$ = Observable.interval$
    .filter(v =&gt; v % 2 === 0)
    .map(v =&gt; v * 2);

// GOOD: This is the new and improved way (lettable operators)
// we just use the pipe operator where we pass operators that
// we can import from 'rxjs/operators'
import {filter, map} from 'rxjs/operators';
const new$ = interval$
    .pipe(
        filter(v =&gt; v % 2 === 0),
        map(v =&gt; v *2)
    )
</code></pre>

<h2 id="ascii-marble-diagrams">ASCII marble diagrams</h2>

<p>Some developers tend to say: “Great code should be self-explanatory, writing documentation is something that we might want to avoid.”
In some cases I would agree with that statement, but for complex RxJS code we might want to reconsider.
Streams can become complex in the following scenarios:</p>
<ul>
  <li>When we take the lifecycle of streams into account, (how long do they live? when do they start living? what destroys them?)</li>
  <li>When we start combining streams (every stream has a different lifecycle remember?)</li>
  <li>When we subscribe multiple times or even subscribe after a while, or even never subscribe to them</li>
</ul>

<p><a href="http://rxmarbles.com/">marble diagrams</a> are a cool way of visualising streams but it’s hard to put those marble-diagrams in our code right?!
There is an ASCII variant of these marble-diagrams that we can use to describe and document our complex streams and how they interact with each other.</p>

<p>ASCII diagrams have more advantages then just documenting:</p>
<ul>
  <li>It gives us a graphic thinking model</li>
  <li>It becomes easy to review someones code and validate to see if it really does what it’s supposed to be doing</li>
  <li>Great to draw on a whiteboard before we start coding</li>
  <li>You can type them in your IDE or editor before you actually start coding. (An easy way to trick your mind into thinking reactively)</li>
  <li>We can use them to write unit tests as well: <a href="http://blog.kwintenp.com/how-to-setup-marble-testing/">Checkout this awesome article</a></li>
</ul>

<p>The concepts behind ASCII marble documentation are quite simple. Take this easy example for instance:</p>

<pre><code class="language-typescript">// ---a--b--c--d---e---...
// ---a--b--c--d---e|
// ---a--b--c--d---e#
// ---a--b-^-c--d---e
</code></pre>
<ul>
  <li><code>-</code> (stands for a time frame)</li>
  <li><code>a-z</code> (are the values that are next’ed in the stream)</li>
  <li><code>|</code> (indicates that the stream has completed)</li>
  <li><code>...</code> (indicates that the stream will keep on living)</li>
  <li><code>#</code> (indicates that an error occurred)</li>
  <li><code>^</code> (indicates where we start subscribing (only for hot streams)</li>
</ul>

<p>Perhaps it’s time to check a real example and how we might document it:</p>

<pre><code class="language-typescript">const interval$ = interval(1000)            // 0--1--2--3--4--5--6...
const new$ = interval$
    .pipe(
        skip(1),                            // ---1--2--3--4--5--6...
        take(5),                            // ---1--2--3--4--5|
        filter(v =&gt; v % 2 === 0),           // ------2-----4-----6
        map(v =&gt; v + 1)                     // ------3-----5-----7
    )
</code></pre>

<p>Take a minute to let this sink into your brain, because this might be <strong>THE WAY</strong> of making a complex code snippets readable for anyone.
When we take a look at this diagram, it’s fairly easy to comprehend what happens, and how every operator affects the <code>new$</code> stream we can see above. There is no “one way of doing things” when it comes to writing ASCII marble-diagrams. You can put them where and how you want.
As we want to do for all other documentation: <strong>keep it up to date!</strong></p>

<h2 id="using-pure-functions">Using pure functions</h2>

<p>RxJS follows the concepts of functional reactive programming which basically means that we will use <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">pure functions</a> to create our reactive flow.
A function is pure when:</p>
<ul>
  <li>It doesn’t mutate anything</li>
  <li>It will always return the same value based on the same parameters</li>
  <li>It doesn’t have any side effects. It can’t mutate state outside of the function</li>
</ul>

<p>In the beginning it might seem pragmatic to use side effects, but that mostly means we aren’t fully thinking reactively. 
Therefore avoid side effects at much as possible.</p>

<h2 id="avoiding-memory-leaks">Avoiding memory leaks</h2>

<p>To consume a stream we need to <strong>subscribe</strong> to that stream. When we subscribe to that stream a <strong>subscription</strong> will be created.
That subscription will keep on living until the stream is <strong>completed</strong> or until we <strong>unsubscribe manually</strong> from that stream.
Managing subscriptions is very important and in a number of cases we will have to manually unsubscribe an existing subscription to avoid memory leaks. Take this example for instance:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit {
   ngOnInit() {
        // The following stream will produce values every second
        // 0--1--2--3--4--5--6--...
        const interval$ = interval(1000);
        // Even when this component gets destroyed,
        // the stream will keep producing values...
        // This means the console will keep on logging
        // This is a classic example of a memory-leak
        const subscription = interval$.subscribe(r =&gt; console.log(r));
    }
}
</code></pre>

<p>To remove the memory-leak in this component we can keep track of the subscriptions by taking advantage of the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    subscriptions = [];
    ngOnInit() {
        const interval$ = interval(1000);
        const subscription = interval$.subscribe(r =&gt; console.log(r));
        // manually keep track of the subscriptions in a subscription array
        this.subscriptions.push(subscription);
    }

    ngOnDestroy() {
        // when the component get's destroyed, unsubscribe all the subscriptions
        this.subscriptions.forEach(sub =&gt; sub.unsubscribe());
    }
}
</code></pre>

<p>However, when we are using a bunch of subscriptions, it can become quite dirty. Before, we talked about the fact that a subscription will live until we manually unsubscribe (like we just did in the snippet above), but also until the stream gets <strong>completed</strong>. A cool way to handle this issue is to use a Subject that we next in the <code>ngOnDestroy()</code> lifecycle hook of Angular:</p>

<pre><code class="language-typescript">class AppComponent implements OnInit, OnDestroy {
    destroy$ = new Subject();
    ngOnInit() {
        // interval$: 0--1--2--3--4--5--6--...
        // destroy$:  -------------true|
        // result:    0--1--2--3--4|
        const interval$ = interval(1000);
        interval$
            // let the interval$ stream live 
            // until the destroy$ Subject gets a value
            .pipe(takeUntil(this.destroy$))
            .subscribe(r =&gt; console.log(r));
    }

    ngOnDestroy() {
        // when the component get's destroyed, pass something to the
        // destroy$ Subject
        this.destroy$.next(true);
    }
}
</code></pre>

<h2 id="avoiding-nested-subscribes">Avoiding nested subscribes</h2>

<p>Nesting subscribes is something that needs to be avoided as much as possible. It makes the code unreadable, complex, and introduces side effects.
It basically forces you to <strong>NOT</strong> think reactively. Take this Angular example for instance:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService)
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // VERY BAD: nesting subscribes is ugly and takes away
        // the control over a stream
        this.route.params
            .pipe(map(v =&gt; v.id))
            .subscribe(id =&gt; 
                this.userService.fetchById(id)
                    .subscribe(user =&gt; this.user = user))
    }
}
</code></pre>

<p>The previous implementation is considered a bad-practice. It’s recommended to use <strong>higher-order streams</strong> like <code>mergeMap</code> or <code>switchMap</code>. Let’s have a look at this example:</p>

<pre><code class="language-typescript">class AppComponent {
    user: User;
    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) 
    {
        // when the params of the route changes,
        // we want to fetch the user and set the user property
        //
        // GOOD: we have created a single subscribe which makes
        // the flow way easier and gives us the control we need
        this.route.params
            .pipe(
                map(v =&gt; v.id),
                switchMap(id =&gt; this.userService.fetchById(id))
            )
            .subscribe(user =&gt; this.user = user)
    }
}
</code></pre>

<h2 id="avoiding-manual-subscribes-in-angular">Avoiding manual subscribes in Angular</h2>

<p>To consume a stream we need to subscribe that stream, that’s simply how observables work. But what if a component needs values from 5 different streams… Would that mean, that we want to subscribe to all of these streams and manually map all the values to unique properties, just to make it work? That would suck, right?!</p>

<p>Angular has this super cool feature called the <code>async pipe</code>. It’s used to consume streams directly in the template
The async pipe does 3 things for us:</p>
<ul>
  <li>It subscribes to the stream and passes the value to a component</li>
  <li>It <strong>unsubscribes automatically</strong> when the component gets destroyed (removes a lot of unsubscribe logic)</li>
  <li>Triggers change detection automatically</li>
</ul>

<p>This means we don’t have to manually subscribe nor unsubscribe anymore. Which cleans up the code a lot.
Let’s have a look at the cleaned up previous example:</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // expose a user$ stream that will be 
    // subscribed in the template with the async pipe
    user$ = this.route.params.pipe(
        map(v =&gt; v.id),
        switchMap(id =&gt; this.userService.fetchById(id))
    );

    constructor(
        private route: ActivatedRoute, 
        private userService: UserService) {
    }
}
</code></pre>

<p>If you are into <a href="https://reactjs.org/">React</a>, I’ve created this lib called <a href="https://www.npmjs.com/package/react-rx-connect">react-rx-connect</a> that would solve this problem. It binds the streams to the state, and unsubscribes from them when the component gets destroyed.</p>

<h2 id="dont-pass-streams-to-components-directly">Don’t pass streams to components directly</h2>

<p>One of the most important aspects of software architecture might be the concept of <strong>decoupling</strong> pieces of code.
Therefore we could consider passing streams to child components as a <strong>bad practice</strong> because it creates a very tight link between the parent component and the child component. They are no longer decoupled since subscriptions in the child component might trigger actions in the parent component. We never want the child component to be responsible of initiating data calls right?! That’s the task of the smart component. See the difference between
<a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">smart and dumb components here</a>.
A component should always receive an object or value and should not even care if that object or value comes from a stream or not.</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;!-- 
            BAD: The users$ steram is passed
            to user-detail directly as a stream 
        --&gt;
        &lt;user-detail [user$]="user$"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent {
    // this http call will get called when the 
    // user-detail component subscribes to users$
    // We don't want that
    users$ = this.http.get(...);
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent implements OnInit {
    @Input() user$: Observable&lt;User&gt;;
    user: User;
    ngOnInit(){
        // WHOOPS! This child component subscribes to the stream
        // of the parent component which will do an automatic XHR call
        // because Angular HTTP returns a cold stream
        this.user$.subscribe(u =&gt; this.user = u);
    }
}
</code></pre>

<p>It would be better to handle the subscription in the parent component itself:</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
@Component({
    selector: 'app',
    template: `
        &lt;user-detail [user]="user$|async"&gt;&lt;/user-detail&gt;
    `
})
class AppComponent implements OnInit {
    users$: Observable&lt;User[]&gt; = this.http.get(...);
    user: User;
    ngOnInit(){
        // the app component (smart) subscribes to the user$ which will
        // do an XHR call here
        this.users$ = this.http.get(...);
    }
    ...
}

// user-detail.component.ts
@Component({
    selector: 'user-detail',
    template: `
        
    `
})
class UserDetailComponent {
    // This component doesn't even know that we are using RxJS which
    // results in better decoupling
    @Input() user: User;
}
</code></pre>

<p>The responsibility of the component is clear. The user-detail is meant to be dumb and is completely decoupled from its parent.</p>

<p>There are however situations where we would like to create a stream from an input. In that case we could take a look at this library: <a href="https://www.npmjs.com/package/ngx-reactivetoolkit">ngx-reactivetoolkit</a></p>

<h2 id="dont-pass-streams-to-services">Don’t pass streams to services</h2>

<p>Although, it might seem like a pragmatic solution to pass streams directly to services, it could be seen as a <strong>bad practice</strong> if we consider the decoupling again. By passing a stream to a service we don’t know what’s going to happen to it. The stream could be subscribed to, or even combined with another stream that has a longer lifecycle, that could eventually determine the state of our application.
Subscriptions might trigger unwanted behavior. And after all, services don’t care that your components are using streams. Take this example for instance:</p>

<pre><code class="language-typescript">// BAD
// app.component.ts
class AppComponent {
     users$ = this.http.get(...)
     filteredusers$ = this.fooService
        .filterUsers(this.users$); // Passing stream directly: BAD
    ...
}

// foo.service.ts
class FooService {
    // return a stream based on a stream
    // BAD! because we don't know what will happen here
    filterUsers(users$: Observable&lt;User[]&gt;): Observable&lt;User[]&gt; {
        return users$.pipe(
            map(users =&gt; users.filter(user =&gt; user.age &gt;= 18))
    }
}
</code></pre>

<p>It would be better to use higher order streams for these situations.
Use <code>switchMap</code> over <code>mergeMap</code> if possible, since it will unsubscribe the previous stream.
The following example is better since all the RxJS logic is centralized in one place where the subscribing and unsubscribing happens: The smart component.</p>

<pre><code class="language-typescript">// GOOD
// app.component.ts
class AppComponent {
    users$ = this.http.get(...)
    filteredusers$ = this.users$
        .pipe(switchMap(users =&gt; this.fooService.filterUsers(users)));
    ...
}

// foo.service.ts
class FooService {
    // this is way cleaner: this service doesn't even know
    // about streams now
    filterUsers(users: User): User[] {
        return users.pipe(filter(user =&gt; user.age &gt;= 18);
    }
}
</code></pre>

<h2 id="sharing-subscriptions">Sharing subscriptions</h2>

<p>Since most streams are cold by default, every subscription will trigger the <strong>producer</strong> of these streams.
The execution of the producer logic on every subscription, might not be what we want if we have multiple subscriptions.
Eg. Subscribing to Angular its <code>http.get()</code> multiple times will actually perform multiple xhr calls.
The following example will trigger the xhr call twice because <code>numberOfUsers$</code> depends on <code>users$</code>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// BAD
class AppComponent {
    users$ = this.http.get(...)
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>In those cases we might want to share the subscriptions. The following example uses the <code>share()</code> operator:</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        Number of users: {{numberOfUsers$|async}}
        &lt;users-grid [users]="users$|async"&gt;&lt;/users-grid&gt;
    `
})
// GOOD
class AppComponent {
    users$ = this.http.get(...).pipe(share());
    // the subscription on this stream will execute the xhr call again
    numberOfUsers$ = this.users$.pipe(map(v =&gt; v.length); 
}
</code></pre>

<p>Sharing a stream makes it hot. This means that if we subscribe after the value is produced, we will miss that value.
In that case we might want to use <code>shareReplay(1)</code> instead of <code>share()</code>. This will keep the last value in memory for us.</p>

<p>It’s a common mistake to share everything. We don’t always want to work with hot streams and sharing subscriptions comes with a small performance cost.Also, lazy streams have their advantages.</p>

<p>Angular also provides a <em>great alternative</em> that can reduce the sharing of streams to a minimum by using the <code>async as else</code> syntax.. 
Personally I would consider the use of this feature as a best practice.
The following example reduces the number of streams, the number of subscriptions and gives us <strong>an easy way to show a loading indicator</strong>.</p>

<pre><code class="language-typescript">@Component({
    selector: 'app',
    template: `
        &lt;div *ngIf="users$|async as users; else loading"&gt;
            Number of users: 
            &lt;users-grid [users]="users"&gt;&lt;/users-grid&gt;
        &lt;/div&gt;
        &lt;ng-template #loading&gt;Loading...&lt;/ng-template&gt;
    `
})
class AppComponent {
    // This stream will only subscribed to once
    users$ = this.http.get(...);
}
</code></pre>

<h2 id="when-to-use-subjects">When to use Subjects</h2>

<p>A Subject is both a hot observable and an observer at the same time. This gives us the opportunity to next values into the stream ourselves.
Subjects tend to be overused by people that didn’t make the mind switch towards reactive programming yet.</p>

<p>Only use them when really needed, for instance it’s ok to use Subjects in the following scenarios:</p>
<h3 id="when-mocking-streams-in-tests">When mocking streams in tests</h3>

<pre><code class="language-typescript">const fetchAll$ = new Subject(); // use a Subject as a mock
usersServiceMock.fetchAll.mockReturnValue(fetchAll$);
fetchAll$.next(fakeUser);
</code></pre>

<h3 id="when-we-want-to-create-streams-from-outputs-in-angular">When we want to create streams from outputs in Angular</h3>

<pre><code class="language-typescript">@Component({
    ...
    template: `
    &lt;some-component (search)="search$.next($event)"&gt;&lt;/some-component&gt;
    `
})
class AppComponent {
search$ = new Subject(); // ----t-----te-----ter----term...
}
</code></pre>

<h3 id="when-handling-circular-references">When handling circular references</h3>

<p>I’m not going to dive in this to deep, but <a href="">Dominic Elm</a> does an awesome job explaining this in <a href="https://blog.thoughtram.io/rxjs/2017/08/24/taming-snakes-with-reactive-streams.html#behaviorsubject-to-the-rescue">this great article</a></p>

<p>For most other cases an operator or Observable.create might be enough.</p>

<p><strong>Note:</strong>
A BehaviorSubject is commonly used because it has a <code>getValue()</code> function. That would also be considered a bad practice.
When we are trying to fetch a specific value it usually means we are not thinking reactive.</p>

<h2 id="clean-code-practices">Clean code practices</h2>
<p>Consistent code indentation and formatting can improve the readability of complex streams:</p>
<ul>
  <li>Align operators below each other</li>
</ul>

<pre><code class="language-typescript">    foo$.pipe(
        map(...)
        filter(...)
        tap(...)
    )
</code></pre>

<ul>
  <li>Extract into different streams when it becomes unreadable</li>
  <li>Put complexer functionality in private methods (make the reactive flow clear)</li>
  <li>Avoid the use of brackets for readability, that’s personal preference.</li>
</ul>

<h2 id="angular-embraces-rxjs">Angular embraces RxJS</h2>

<p>We already saw a glimpse of why Angular is a framework that really embraces the use of RxJS.
Therefore it’s recommended to use the functionality that Angular provides.</p>
<ul>
  <li>The <code>ActivatedRoute</code> has exposes a params stream.</li>
  <li>The Http and HttpClient both return streams</li>
  <li>The <code>Form</code> and <code>FormControl</code> both have a <code>valueChanges</code> property that returns a stream</li>
  <li>The async pipe is an awesome feature that really helps us to use the streams in our templates</li>
  <li>Using the <code>ngOnInit()</code> lifecycle function to initialize streams can help us for mocking purposes</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Still here? Awesome! We learned a lot! If this article interests you, you might want to check out the “Advanced RxJS in Angular workshop” from <a href="https://strongbrew.io">Strongbrew</a>, where me and <a href="blog.kwintenp.com">Kwinten Pisman</a> teach how to use advanced RxJS in real Angular applications.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Safe image requests in angular</title>
	  <link>//safe-image-requests-in-angular/</link>
	  <author></author>
	  <pubDate>2017-10-24T00:00:00+00:00</pubDate>
	  <guid>//safe-image-requests-in-angular/</guid>
	  <description><![CDATA[
	     <p>We all know how to load images in a web-application right? We would just make use of the img DOM-element, define its src attribute and we are good to go. Everything would happen automatically. However, there is a big security-issue with this approach.</p>

<p>Take this hypothetical application for instance: We have an app that is used to manage pictures and this particular app can have multiple users. It makes sense that every user owns their own images, right? For privacy reasons user A could never consume the images of user B. Since images are loaded through the DOM with the img DOM-element, it might be hard to add authorization there. Take this angular snippet for instance:</p>

<pre><code class="language-typescript">@Component({
    template: `
        &lt;img [src]="img.src"/&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
}
</code></pre>

<p>Since the browser just loads this image through a normal HTTP call, how is the server supposed to know if user A or user B is trying to consume this image? The server needs some kind of authorization to be passed to it.</p>

<h2 id="passing-the-authorization-with-session-cookies">Passing the authorization with Session cookies</h2>

<p>We could use session cookies, which kinda works like this: The user authenticates with the backend of our app, receives a session cookie which will be passed with every future request. That way the backend knows who is trying to consume the resource in question.</p>

<p>Some could argue that session cookies are not to way the go, and stateless backends are better and more scalable.
If we use JWT or any other modern authentication system we would rather send <strong>authorization-headers</strong> instead of using the session cookie approach. The value that our server should receive in the authorization-header is called a <strong>Bearer token</strong>.</p>

<h2 id="passing-the-authorization-without-cookies">Passing the authorization without cookies</h2>

<p>Let’s explore 2 different methods to pass Bearer tokens to the backend:</p>

<h3 id="passing-the-token-in-the-url">Passing the token in the url</h3>

<p>In this case we would just pass the token as a <strong>query parameter</strong> in the url. The previous snippet would now look like this:</p>

<pre><code class="language-typescript">@Component({
    template: `
        &lt;img [src]="img.src + '?bearer=' + bearToken"/&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
    bearerToken  = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';
}
</code></pre>

<p>The url of the server request would now look like this: <em>https://angular.io/assets/images/logos/angular/logo-nav@2x.png?bearer=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9…</em></p>

<p>Based on the token, the server knows which user tries to load the image and can block unauthorized users of fetching that image.</p>

<p>There are a few tradeoffs:</p>

<ul>
  <li>The Token is there for everyone to see in the URL (less secure, but then again, they could still check it in the offline-storage)</li>
  <li>Every time the token changes, the cache would be cleared, since the url of the resource changes</li>
  <li>The backend would need a way to handle all the image calls that contain a bearer token in their url</li>
  <li>We need to load and parse the token everywhere we load images in our components</li>
  <li>Doesn’t work for css, unless it’s dynamically created</li>
</ul>

<h3 id="handling-the-images-with-ajax-calls">Handling the images with AJAX calls</h3>

<p>In this approach we will create a generic way of handling image-security by using:</p>

<ul>
  <li>A generic component</li>
  <li>AJAX calls with a blob responseType</li>
  <li>HTTP interceptors (introduced by the new HttpClient in angular 4.3)</li>
  <li>Data urls</li>
</ul>

<p>We would like to consume images like this:</p>

<pre><code class="language-typescript">@Component({
    template: `
          &lt;secured-image [src]="img.src"&gt;&lt;/secured-image&gt;
    `
})
export class FooComponent {
    img = {
        src: 'https://angular.io/assets/images/logos/angular/logo-nav@2x.png'
    }
}
</code></pre>

<p>Let’s create a <strong>secured-image</strong> component as shown above.
This component needs to handle the following:</p>

<ul>
  <li>Load an image through an AJAX call</li>
  <li>Create a data url based on a blob</li>
  <li>When the source changes:
    <ul>
      <li>Cancel the previous AJAX call (if it’s still busy)</li>
      <li>Start loading the new resource through AJAX</li>
    </ul>
  </li>
  <li>When the component gets destroyed, cancel the current AJAX call (if it’s still busy)</li>
</ul>

<p>In the beginning, this might look like this:</p>

<pre><code class="language-typescript">@Component({
  selector: 'secured-image',
  template: `
    &lt;img [src]="dataUrl$|async"/&gt;
  `
})
export class SecuredImageComponent implements OnChanges  {
  // This code block just creates an rxjs stream from the src
  // this makes sure that we can handle source changes
  // or even when the component gets destroyed
  // So basically turn src into src$
  @Input() private src: string;
  private src$ = new BehaviorSubject(this.src);
  ngOnChanges(): void {
    this.src$.next(this.src);
  }

  // this stream will contain the actual url that our img tag will load
  // everytime the src changes, the previous call would be canceled and the
  // new resource would be loaded
  dataUrl$ = this.src$.switchMap(url =&gt; this.loadImage(url))
  
  // we need HttpClient to load the image
  constructor(private httpClient: HttpClient) {
  }

  private loadImage(url: string): Observable&lt;any&gt; {
    return this.httpClient
      // load the image as a blob
      .get(url, {responseType: 'blob'})
      // create an object url of that blob that we can use in the src attribute
      .map(e =&gt; URL.createObjectURL(e))
  }
}

</code></pre>

<p>This pretty much covers everything, but if we check it in the browser we get the following error.
<strong>WARNING: sanitizing unsafe URL value blob:https://localhost:4200/da89c71e-5df2-4842-af06-993cd5263471 (see http://g.co/ng/security#xss)</strong></p>

<p>Loading the image through AJAX does not work yet because we haven’t sanitized the url yet. For that we need the <strong>DomSanitizer</strong> that angular provides us. This is a security mechanism to protect the app from XSS-attacks. We basically have to tell angular which urls to trust.</p>

<pre><code class="language-typescript">export class SecuredImageComponent implements OnChanges  {
  ...
  // inject the domSanitizer here as well
  constructor(private httpClient: HttpClient, private domSanitizer: DomSanitizer) {
  }

  private loadImage(url: string): Observable&lt;any&gt; {
    return this.httpClient
      .get(...)
      // pass the url through the domSanitizer so angular knows he can parse it
      .map(e =&gt; this.domSanitizer.bypassSecurityTrustUrl(URL.createObjectURL(e)))
  }
}

</code></pre>

<p>We now have a fully working way of loading images through AJAX calls. However, we still haven’t passed our Bearer token.
We could add the the authorization header in the get call directly, but let’s find a cleaner solution.
Since we use httpClient, this opens up a few doors for us.
The new HttpClient, which was introduced in angular 4.3 offers a few new features. One of these features are <strong>interceptors</strong>.
Interceptors are a way to hook into http calls that are being made by the new HttpClient.</p>

<p>This would be a perfect solution to pass the bearer token wouldn’t you agree?</p>

<p>Let’s create the interceptor and register it to angular.</p>

<pre><code class="language-typescript">// my-http.interceptor.ts
@Injectable()
export class MyHttpInterceptor implements HttpInterceptor {
  // intercept any http call done by the httpClient
  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    // fetch the bearer token from wherever you have stored it
    // NOTE: fetching it directly from window is not a good idea (demo purpose)
    const jwtToken = window.localStorage.getItem('jwtToken');

    // if there is a token, clone the request and set the correct
    // authorization header, if not =&gt; just use the old request
    const requestToHandle = jwtToken
      ? request.clone({
        headers: request.headers.set('authorization', `Bearer ${jwtToken}`)
      })
      : request;
    return next.handle(requestToHandle);
  }
}

// app.module.ts
@NgModule({
  ...
  // don't forget to import the HttpClientModule
  imports: [ BrowserModule, FormsModule, HttpClientModule ],
  providers: [{
    // register the interceptor to our angular module
    provide: HTTP_INTERCEPTORS, useClass: MyHttpInterceptor, multi: true
  }]
})
export class AppModule { }
</code></pre>

<p>If you would like to learn more about interceptors, check this <a href="https://juristr.com/blog/2017/08/intercept-http-requests-in-angular/">awesome article</a> by <a href="https://twitter.com/juristr">Juri Strumpflohner</a>.
He also has an amazing egghead course on that subject.</p>

<p>Right now, every call that the secured-image component has initiated will load the image through AJAX with the right authorization header. That way the server can check who has been asking for that specific resource.</p>

<p>However, this approach also introduces a few tradeoffs:</p>

<ul>
  <li>CORS headers for CDN resources. Since we are using a GET AJAX call there will be extra OPTIONS calls.</li>
</ul>

<p>Extra advantages:</p>
<ul>
  <li>It’s easier to handle the loading of the image, show a spinner or animation</li>
  <li>Doesn’t work for css, unless it’s dynamically created</li>
</ul>

<p>You can find the complete source of a working version in this <a href="https://stackblitz.com/edit/secure-image-loads">stackblitz example</a>.</p>

<h2 id="thanks-for-reading">Thanks for reading</h2>
<p>I hope you all liked this article, if you have questions, shoot!</p>

	  ]]></description>
	</item>

	<item>
	  <title>A scalable angular architecture (part 2)</title>
	  <link>//A-scalable-angular-architecture-part2/</link>
	  <author></author>
	  <pubDate>2017-08-13T00:00:00+00:00</pubDate>
	  <guid>//A-scalable-angular-architecture-part2/</guid>
	  <description><![CDATA[
	     <h1 id="the-sandbox-pattern">The sandbox pattern</h1>

<h2 id="introduction">Introduction</h2>
<p>A while ago I released a blogpost called “<a href="http://blog.brecht.io/A-scalable-angular2-architecture/">A scalable angular 2 architecture</a>” which was all about creating large scale enterprise webapplications. The title should actually have been <strong>“A scalable angular architecture”</strong> (It’s just angular) or even, <strong>“A scalable SPA architecture”</strong> since we can use the same architecture for <a href="https://facebook.github.io/react/">React</a> or <a href="https://vuejs.org">Vue.js</a>.</p>

<p>It’s been over a year now, since I’ve been introducing that specific architecture in companies and projects. Nowadays, I know quite a few people that are using this particular architecture in their projects.
Often, I ask developers about how they feel about this SPA-architecture and the feedback is mostly this:
They believe its a <strong>clear and opiniated way</strong> to structure their code, and they have no trouble, finding their way into the codebase.</p>

<p>A big part of the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">article</a> in question, was about explaining the so called “sandboxes”, a personal terminology for a very specific kind of facade.
Since writing that <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">article</a> raised a bunch of questions about these “sandboxes”, it seemed like a good idea to write a followup article.</p>

<p>In this article we will cover what sandboxes are really about and why I introduced them in the first place.</p>

<p><strong>Note: This architecture is only one way of structuring your applications and the statements being made in this article are completely personal and might be opiniated.</strong></p>

<h2 id="what-is-a-sandbox-in-a-nutshell">What is a sandbox in a nutshell</h2>

<p>In real life it’s a place where we can put our children together with a limited set of toys. That way, they can only play with those toys and have fun, and we as parents wouldn’t have to worry about them running around in the garden.</p>

<p>In this architecture a sandbox is a controlled environment, and the only place where components can consume pieces of the application.
It’s the only interface for our smart components to communicate with the rest of the application. It’s a facade that abstracts away logic from our components. It does have very specific logic though.</p>

<h2 id="here-is-why-i-introduced-sandboxes">Here is why I introduced sandboxes</h2>

<p>One of the most challenging parts of creating big clientside javascript applications is encapsulation and dividing responsibilities. Having a decent encapsulated structure where every component, service, class has a clear reason of existence, makes it easy for us as developers to maintain the code and develop new features.</p>

<p>When writing single-page-applications one could face the following challenges:</p>

<h3 id="challenge-1-how-do-we-structure-components">Challenge 1: How do we structure components?</h3>

<p>Since this topic is covered in the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">previous article</a>, we won’t do a deepdive in this subject.
We use the smart/dumb component approach to structure our components. The dumb components mostly have presentational purposes and the smart components interact with the rest of the application.</p>

<h3 id="challenge-2-how-do-we-handle-statemanagement">Challenge 2: How do we handle statemanagement?</h3>

<p>Another topic covered by the <a href="http://blog.brecht.io/A-scalable-angular2-architecture/">previous article</a> is how handle our statemanagement. In short: we use @ngrx/store, or another redux implementation that embraces reactive programming.</p>

<h3 id="challenge-3">Challenge 3</h3>

<p>The first two challenges are met: we have a clear and structured presentational layer and because of the fact that we use @ngrx/store (or any statemanagement tool for that matter), we have a clear way of managing state. We can optimise performance with immutable data and still have clear unidirectional dataflow.</p>

<p>However, there are still a few pieces of the puzzle missing, which might raise the following questions:</p>

<h4 id="how-do-we-separate-the-presentation-layers-from-the-rest-of-the-application">How do we separate the presentation-layers from the rest of the application?</h4>

<p>If we inject whatever we want in our smart components, their constructors might get huge in no-time. Do those smart components really need to know everything about the application? Do they need to know where everything lives and what service it should call from which module in the application? Wouldn’t it be easier if they had an interface they could talk to, that just handles things for them?
It would certainly help to decouple angular modules from each other, and keep the responsibility of those smart components clear and compact. <strong>This is something a sandbox might be able to help us with.</strong></p>

<h3 id="do-our-components-need-to-know-about-redux">Do our components need to know about redux?</h3>

<p>Redux is an awesome library/principle that helps us ace statemanagement, but it’s a really heavy dependency if you don’t manage it carefully. What if your <strong>very specific</strong> redux actions would be everywhere in your components and services? In that case your codebase would be completely affected by it and it would be very hard to use another statemanagement tool in the future. It would be impossible to share that code in non-redux applications.
It would be a huge depencency… What if you like to switch to firebase for instance, or MOBX, or even write your own statemanagement tool. You would need to refactor your whole application. The sole principle of redux is to manage state, and I prefer to use it that way. That is also why I don’t really use effects, thunk or saga. (That’s a personal preference)
For me this means: <strong>Use redux only to manage state, not to trigger backend actions etc</strong>
One could even argue that the action-dispatching and state-selecting should be combined in central places in your appliction.
 <strong>Let’s add that logic to the sandboxes as well.</strong></p>

<h4 id="do-our-http-services-need-to-know-about-a-redux-implementation">Do our HTTP services need to know about a redux implementation?</h4>

<p>Well, as the name already reveals. An HTTP service is all about doing HTTP communication and returning asynchronous objects to the components. An HTTP service should have no notion about redux at all nor any other statemanagement tool. Its sole purpose is fetching data and returning it. Let’s take a look at the following example for instance. We fetch an array of wines from the backend and we want to persist that in a redux store. This is an example of an HTTP service that is being abused to achieve that:</p>

<pre><code class="language-typescript">class WineService {
	// bad
	fetchWines(): void {
		this.api.get('url')
			.subscribe(wines =&gt; 
				this.store.dispatch({type: 'SET_WINES', payload: {wines}});
	}
}
</code></pre>

<p>This code doesn’t belong here, it’s not the responsibility of that service. The question is where does it belong?
Does it belong in the component? They would get dirty and reduxy in no-time…
<em>*Again, this would belong to the sandbox!</em>.</p>

<p>An http service should look like this:</p>

<pre><code class="language-typescript">class WineService {
	// good
	fetchWines(): Observable&lt;any&gt; {
		return this.api.get('url')
	}
}
</code></pre>

<h4 id="on-what-place-do-we-dispatch-actions-to-the-store">On what place do we dispatch actions to the store?</h4>

<p>Err…, the sandbox =)</p>

<h4 id="where-do-we-handle-optimistic-updates">Where do we handle optimistic updates</h4>

<p>Again, that would be the sandbox</p>

<h4 id="how-to-not-make-your-whole-application-smell-like-redux">How to NOT make your whole application smell like REDUX</h4>

<p>Components and services should not know about redux, so the store interaction should be in a very specific place as well.</p>

<p>I bet you saw it coming, but YES! That’s what a sandbox is all about! It’s about separation of concerns and having a very specific interface to handle this very specific logic.</p>

<h2 id="what-does-a-sandbox-do">What does a sandbox do?</h2>

<p>A sandbox has a very specific responsibility:</p>

<ul>
  <li>It lets your module communicate with other modules without that module having to know about the rest of the application</li>
  <li>It sends Redux actions</li>
  <li>It exposes streams of data (coming from Redux, Firebase or other technologies)</li>
  <li>It handles optimistic updates</li>
  <li>It keeps the containers stupid enough</li>
</ul>

<h2 id="whats-very-specific-on-a-sandbox">What’s very specific on a sandbox?</h2>

<ul>
  <li>They handle what the container tells them to handle, without the container having to know how…</li>
  <li>They interact between modules</li>
  <li>They handle a lot of redux (or similar technology) logic</li>
  <li>The functions mostly have a void return-type, unless we want to be able to cancel HTTP calls</li>
  <li>They expose observables/streams</li>
  <li>It mostly contains redundant code, but no redundant logic (it’s all about KISS instead of DRY)</li>
  <li>Mostly every module has a sandbox, unless it contains a huge amount of logic (in that case we could implement a sandbox for every container)</li>
  <li>It does not contain business logic, ever…</li>
  <li>It mostly doesn’t contain if-statements, that would be business logic right?!</li>
  <li>It gives us a clear overview of the responsabilities of a module.</li>
</ul>

<h2 id="what-doesnt-a-sandbox-do">What doesn’t a sandbox do?</h2>

<ul>
  <li>It doesn’t contain business logic. It contains sandbox logic (see above).</li>
  <li>It doesn’t contain presentation logic, like routing etc.</li>
  <li>It doesn’t do HTTP calls directly, it delegates to http services.</li>
  <li>It doesn’t let your components do whatever they want =)</li>
</ul>

<h2 id="an-example">An example</h2>

<pre><code class="language-typescript">@Injectable()
export class StockSandbox {
	// these are the store select statements
	// It's pretty dirty to have them all over our components
	// Our components just want to get streams of data, no matter where they come from
	wines$ = this.store.select(state =&gt; state.wines);
	isAuthenticated$ = this.store.select(state =&gt; state.authentication.isAuthenticated);

	constructor(
		private store: Store&lt;ApplicationState&gt;, 
		private stockService: StockService,
		private fooService: FooService) {
	}

	addWine(wine: Wine): void {
		// use the stockservice to add a wine
		// and when it's done handle our statemanagement
		this.stockService.add(wine).subscribe((wine: Wine) =&gt; {
			this.store.dispatch(new AddWine(wine));
		}, () =&gt; this.handleError());
	}

	 removeWine(wine: Wine): void {
		// removing a wine can be done optimistically!
		// this would certainly improve the performance and snappyness of our app
		// this would be sandbox logic
		let action = new RemoveWine(wine._id);
		this.store.dispatch(action);
		this.stockService.remove(wine).subscribe(
			() =&gt; {}, 
			// if the call failed, we have to undo an action. This is sandbox logic as well!
			() =&gt; this.store.dispatch({type: UNDO_ACTION, payload: action}););
	}

	fetchWine(id: string): Observable&lt;Wine&gt; {
		// simple delegation of fetching something: Sandbox logic
		return this.stockService.fetchWine(id).share();
	}

	notifyAnotherModule(): void {
		// our components should NOT know where fooService is, or what it does
		// it should just tell its sandbox to handle a specific action
		this.fooService.doSomething();
	}
}
</code></pre>

<p>Look how clean this smart component has become:</p>
<pre><code class="language-typescript">export class StockPageContainer {
    wines$ = this.sb.wines$; // Does this stream comes from Redux? or Firebase (I don't need to know)
    numberOfWines$ = this.wines$.map(wines =&gt; sumBy(wines, (wine: Wine) =&gt; wine.inStock));

	// a clean constructor makes it easy to test.
	// Util dependencies or presentational dependencies like a router
	// do not belong in the sandbox.
	// They belong right here in the component, in the presentational layer.
    constructor(private sb: StockSandbox, private router: Router) {
    }

    onRemove(wine: Wine): void {
		// Hey Sandbox! Remove the wine please, I don't care how you do it
		// I don't even care that you do optimistic updates, it's not my business
        this.sb.removeWine(wine);
    }

    notifyAnotherModule(): void {
		// I don't know what will happen, but that's okay... It's not my responsability
        this.sb.notifyAnotherModule(); 
    }
}

</code></pre>

<p>I hope this clarifies the purpose of the sandbox and why I have introduced them in my projects.
If you still have questions about this approach, don’t hesitate to contact me =)</p>

<h3 id="special-thanks">Special thanks</h3>
<p>Special thanks to <a href="'https://twitter.com/ManfredSteyer'">Manfred Steyer (@manfredsteyer)</a> and <a href="https://twitter.com/juristr">Juri Strumpflohner (@juristr)</a> for reviewing this article!</p>


	  ]]></description>
	</item>

	<item>
	  <title>Thinking reactively in Angular and RXJS</title>
	  <link>//thinking-reactively-in-angular-and-rxjs/</link>
	  <author></author>
	  <pubDate>2017-07-25T00:00:00+00:00</pubDate>
	  <guid>//thinking-reactively-in-angular-and-rxjs/</guid>
	  <description><![CDATA[
	     <h2 id="foreword">Foreword</h2>

<p>RxJS is an awesome library that can help us with creating <strong>reactive web applications</strong>. Reactive web applications can be overwhelming in the beginning, but eventually, they can be really rewarding.</p>

<p>This article is all about making the paradigm switch from thinking imperatively towards <strong>thinking reactively</strong>.
In this article, we will explain how to write a reactive calendar application in only a few lines of code (<strong>spoiler: It’s gonna be real time too</strong>).</p>

<p>We will use Angular, Angular Material, TypeScript, RxJS, Firebase, and AngularFire as our main technology stack. Keep in mind that this article really focusses on reactive programming. Don’t expect a deep dive into all RxJS operators, but rather expect an explanation of how to draw, think, and reason about reactive web applications. We will learn <strong>how to think in streams</strong>. If you haven’t heard of streams yet, please read <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">this awesome article</a> first.</p>

<p><strong>Note:</strong> This article contains personal terminology.</p>

<h2 id="the-reactive-calendar">The Reactive Calendar</h2>
<p>This is the application we are going to write. It’s a small but complete calendar application that allows us to:</p>

<ul>
  <li>Switch between different view modes: day, week, month.</li>
  <li>Navigate to previous and next days, weeks, and months.</li>
  <li>Add, update, and remove appointments.</li>
  <li>Search for specific appointments.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar1.png" alt="Reactive calendar" /></p>

<p>The user can interact with the following UI elements:</p>

<ul>
  <li><strong>Next button:</strong> Allows the user to go to the next day in day mode, week in week mode, etc.</li>
  <li><strong>Previous button:</strong> Allows the user to go to the previous day in day mode, week in week mode, etc.</li>
  <li><strong>Day, week, month buttons:</strong> Allows the user to switch between the different view modes</li>
  <li><strong>Search term input:</strong> Allows the user to filter the appointments on the fly</li>
  <li><strong>Plus-buttons in the grid:</strong> Allows the user to create new appointments</li>
  <li><strong>Trashcan buttons in the grid:</strong> Allows the user to remove appointments</li>
  <li><strong>Description inputs:</strong> Allows the user to update the description of an appointment</li>
</ul>

<p>I decided to use Firebase as a backend and because of that, our application will be realtime and offline first by default!</p>

<p><strong>Note:</strong> One small issue, I’ve been a bit lazy so we can only create lunch appointments. =) But hey! Consider it some homework.</p>

<h2 id="setting-up-the-project">Setting Up the Project</h2>

<p>I’ve created the git branch <strong>initial</strong> to get us started. It contains the default logic/components, setup, and styles. There is no reactive code written yet, just plain Angular code. The goal is to write the reactive part ourselves.</p>

<h3 id="the-component-tree">The Component Tree</h3>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar3.png" alt="The component tree" />
The dumb components (blue) are already implemented. The <code>app-root</code> (orange) is the one and only smart component in the application and the only place where we will write code.</p>

<p>If you don’t know the difference between smart and dumb components, <a href="http://blog.brecht.io/components-demystified/#smart-vs-dumb-components">read this first</a>.</p>

<h3 id="installing-the-project-locally">Installing the Project Locally</h3>
<p>First of all, we have to clone the project locally and check out the <strong>initial</strong> branch. This branch already contains all the uninteresting parts that don’t have anything to do with this article.</p>

<p>In the terminal, we have to go to the folder where we want to install the project and run the following commands:</p>

<pre><code>$ git clone git@github.com:brechtbilliet/reactive-calendar.git
$ cd reactive-calendar/reactive-calendar
$ git checkout initial
$ npm install
</code></pre>

<h3 id="setting-up-firebase">Setting Up Firebase</h3>

<p>We are using <a href="https://firebase.google.com/">Firebase</a> as our backend because it requires minimal setup, it’s realtime by default, and <a href="https://github.com/angular/angularfire2">AngularFire</a> gives us streams for free. We can complete the Firebase configuration in a few steps:</p>

<ul>
  <li>Go to <a href="https://firebase.google.com/">https://firebase.google.com</a>, click on the “GO TO CONSOLE” button, and choose your Google account.</li>
  <li>Click on the “Add project” button and choose a name for your project. Let’s take <strong>“reactive-calendar”</strong> to keep it simple.</li>
  <li>Click on the “CREATE PROJECT” button. Now we should be redirected to <a href="https://console.firebase.google.com/project/reactive-calendar/overview">something like this</a>.</li>
  <li>In the Authentication tab, go to “SIGN-IN METHOD” and enable the “Anonymous” setting.</li>
  <li>Click on database and navigate to the rules tab. Set the read and write property to “true” and click “publish”:
    <pre><code class="language-json">{
  "rules": {
      ".read": "true",
      ".write": "true"
  }
}
</code></pre>
  </li>
  <li>Go back to the overview by clicking on the home icon, and then select “Add Firebase to your web app”.</li>
  <li>Copy the config with the correct properties and replace the firebaseConfig object in src/app/app.module.ts with these properties.
It might look something like this:</li>
</ul>

<pre><code class="language-typescript">const firebaseConfig = {
    apiKey: "AIzaSyBuqjTJd5v6xTf8D2EZmvFUl8lseH8lVuHU",
    authDomain: "reactive-calendar.firebaseapp.com",
    databaseURL: "https://reactive-calendar.firebaseio.com",
    projectId: "reactive-calendar",
    storageBucket: "reactive-calendar.appspot.com",
    messagingSenderId: "3978123451455750"
};
</code></pre>

<p>Let’s continue. Start the project by running the following command and open your browser on <a href="http://localhost:4200">http://localhost:4200</a>.</p>

<pre><code>npm start
</code></pre>

<p>As you can see, this just handles static data, the buttons/inputs won’t work, and the appointments are not loaded yet.
This is where we start from.</p>

<h2 id="thinking-reactively">Thinking Reactively</h2>

<p>Now comes the tricky part. We are trying to forget imperative programming for now, and we are trying to evolve into a reactive mindset.</p>

<h3 id="marble-diagrams">Marble Diagrams</h3>

<p>To be able to think reactively, we need some kind of graphic model so we can picture streams in our head. Marble diagrams are a great way to do that.
As you can see in the image below, a marble represents a value over time.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar12.png" alt="Marble diagrams" /></p>

<p>The website <a href="http://rxmarbles.com/">rxmarbles.com</a> has a great playground for learning how to use and draw marble diagrams.</p>

<h4 id="ascii-documentation">ASCII Documentation</h4>

<p>One could argue that code should not be documented and be self-explanatory. I don’t believe that to be the case when writing complex streams. When we document complex streams, we can see what’s going on inside the stream, which makes it easier for our colleagues.
Streams can be documented by ASCII documentation. Since that is not really part of this article, I’m only going to show a small example below.</p>

<pre><code class="language-typescript">// a$ gets three values over time and then stops
// a$: -------a-----b-----c|

// b$ has an initial value (a), has three values in total
// and will keep on living
// b$: a------b-----c------...
</code></pre>

<h3 id="imperative-programming-what-does-the-app-have-to-do">Imperative Programming: What Does the App Have to Do?</h3>

<p>When we think about the functionality of our application, we quickly notice that there are quite a few corner cases and special scenarios. For every interaction the user makes in the UI, the app needs to handle that specific interaction accordingly. Sometimes it has to combine these interactions and handle that specific combination as well. Take this crazy (but simple) example, for instance.</p>

<blockquote>
When the view mode is changed to week mode, and the previous view mode was month mode, and the month was June, and the year was 2017, and an appointment was added, while the search term was set to "Brecht", then we would have to update...
</blockquote>

<p>Yes, we would have to update a bunch of stuff. This is imperative thinking, and it can become exhausting. There is a big chance that we forget certain corner cases. Let’s not even imagine that we have to combine that with asynchronous actions as well.</p>

<p>In the image below, we see all the different interactions the user has in the calendar application.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar2.png" alt="Application events" /></p>

<p>As we can see, for every specific interaction, the UI will have to update specific things.</p>

<h3 id="reactive-programming-what-data-will-change-and-what-data-do-the-components-need">Reactive programming: What Data Will Change, and What Data Do the Components Need?</h3>

<h4 id="source-streams">Source Streams</h4>

<p>Now, let’s completely stop with what we are thinking. Let’s free our minds and stop thinking about corner cases and special scenarios. We have to learn to think in streams. A stream is a collection of events that will change over time. Think about what can change in your application and call these streams of data. Let’s call them <strong>source streams</strong>.</p>

<p><strong>Note:</strong> For readability purposes, we will suffix all the streams with a <code>$</code> symbol.</p>

<p>We can come up with 4 source streams:</p>

<ul>
  <li><strong>navigation$:</strong> Can contain the values: -1, 0 or 1</li>
  <li><strong>viewMode$:</strong> Can contain the values: DAY, WEEK, or MONTH</li>
  <li><strong>searchTerm$:</strong> The value of the search field</li>
  <li><strong>appointments$:</strong> This is an array of appointments that comes from Firebase</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar4.png" alt="data streams" /></p>

<p>That was pretty easy. We just had to think about the events that can occur in our application. A user can navigate, change view mode, search for appointments, and the appointments in Firebase can change. This is the beginning of thinking reactively. Don’t think about who triggers what. Think about the changes as streams.</p>

<p>It’s always a good idea to draw marble diagrams to make it easier to reason.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar5.png" alt="data stream diagram" /></p>

<p><code>The appointments$</code> is a stream that will be provided to us by AngularFire, but the <code>viewMode$</code>, <code>searchTerm$</code>, and <code>navigation$</code> are simple behavior subjects. We use subjects because we need to control the values of the streams ourselves, and we use the <code>BehaviorSubject</code> in particular because all our source streams need an initial value.</p>

<pre><code class="language-typescript">export class AppComponent {
    ...
    // this is how we can retrieve the list of appointments from angularfire
    appointments$ = this.db.list('/appointments');
     // 0--------(+1)----(+1)----(-1)-------------...
    viewMode$ = new BehaviorSubject(VIEW_MODE.MONTH);
    navigation$ = new BehaviorSubject(0);
    searchTerm$ = new BehaviorSubject('');

	// because we set up the angularfire configuration correctly, we can just
	// inject the angularfiredatabase right here and use it
    constructor(private db: AngularFireDatabase) {
    }
    ...
}

</code></pre>

<p>These subjects get values from the simple interactions from the template.</p>

<pre><code class="language-typescript">@Component({
    ...
    template: `
        &lt;topbar
                (next)="onNext()"
                (previous)="onPrevious()"
                (setViewMode)="onSetViewMode($event)"
                (searchChanged)="onSearchChanged($event)"&gt;
        &lt;/topbar&gt;
        ...
    `
})
export class AppComponent {
    ...
    
    onSetViewMode(viewMode: string): void {
        // when the viewmode changes, update its subject
        this.viewMode$.next(viewMode);
    }

    onPrevious(): void {
        // when the user clicks the previous button
        // update the navigation subject
        this.navigation$.next(-1);
    }

    onNext(): void {
        // when the user clicks the next button
        // update the navigation subject
        this.navigation$.next(1);
    }

    onSearchChanged(e: string): void {
        // when the user searches
        // update the searchterm subject
        this.searchTerm$.next(e);
    }
}

</code></pre>

<h4 id="presentational-streams">Presentational Streams</h4>

<p>Now we have to think about the data that our components need, because those components will need to be updated based on those source streams.
Let’s take this code sample, for instance:</p>

<pre><code class="language-html">&lt;div [ngSwitch]="XX" class="main"&gt;
    &lt;day-view
            *ngSwitchCase="'DAY'"
            [appointments]="XX"
            [date]="XX"
            ...&gt;
    &lt;/day-view&gt;
    &lt;week-view
            *ngSwitchCase="'WEEK'"
            [appointments]="XX"
            [year]="XX"
            [week]="XX"
            ...&gt;
    &lt;/week-view&gt;
    &lt;month-view
            *ngSwitchCase="'MONTH'"
            [month]="XX"
            [year]="XX"
            [appointments]="xxx"
            ...&gt;
    &lt;/month-view&gt;
&lt;/div&gt;
</code></pre>

<p>I marked the input properties with XX to show what our components need in terms of data. These places will need streams as well. Let’s call them <strong>presentational streams</strong>.</p>

<p>Let’s try to fill in these gaps, shall we?</p>

<p><strong>Note:</strong> We use the <a href="https://angular.io/api/common/AsyncPipe">async pipe</a> from Angular to subscribe/unsubscribe the streams automatically.</p>

<pre><code class="language-html">&lt;div [ngSwitch]="viewMode$|async" class="main"&gt;
    &lt;day-view
            *ngSwitchCase="'DAY'"
            [appointments]="filteredAppointments$|async"
            [date]="currentDate$|async"
            ...&gt;
    &lt;/day-view&gt;
    &lt;week-view
            *ngSwitchCase="'WEEK'"
            [appointments]="filteredAppointments$|async"
            [year]="currentYear$|async"
            [week]="currentWeek$|async"
            ...&gt;
    &lt;/week-view&gt;
    &lt;month-view
            *ngSwitchCase="'MONTH'"
            [month]="currentMonth$|async"
            [year]="currentYear$|async"
            [appointments]="filteredAppointments$|async"
            ...&gt;
    &lt;/month-view&gt;
&lt;/div&gt;
</code></pre>

<p>We have gathered the 6 following presentational streams:</p>

<ul>
  <li><strong>viewMode$ (string):</strong> needed to determine which view has to be shown</li>
  <li><strong>filteredAppointments$ (Array &lt; Appointment &gt;):</strong> needed by day view, week view, and month view to render the correct appointments</li>
  <li><strong>currentDate$ (date):</strong> the current date for the day view</li>
  <li><strong>currentWeek$ (number):</strong> the current week for the week view</li>
  <li><strong>currentYear$ (number):</strong> needed by week view and month view</li>
  <li><strong>currentMonth$ (number):</strong> needed by the month view</li>
</ul>

<p>Okay, great, we know the source streams, which are the sources of change in our application.
We know the presentational streams, which are simply the streams that our components need. Now it’s time for the cool part: <strong>We need to create those presentational streams based on the source streams</strong>.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar6.png" alt="sources to presentational streams" /></p>

<p>The first presentational stream we need is <code>viewMode$</code>. This is already an easy one, since <code>viewMode$</code> is also a source stream.</p>

<h4 id="currentdate">currentDate$</h4>
<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar7.png" alt="currentDate$" /></p>

<p><strong>Note:</strong> We use moment.js for date calculation. The suffix M after the currentDate property shows that the type is <code>Moment</code>. So in short, it’s not just a date, but a moment wrapper.</p>

<pre><code class="language-typescript">// we will need this stream a few times, so let's extract the stream 
// in a currentDateM first

// viewMode$:     M------------------W---------------D--------...
// navigation$:   0---(+1)-(-1)----------(+1)-(-1)------------...
// currentDateM$: d---d----d---------d---d----d------d--------...
private currentDateM = this.viewMode$.flatMap((viewMode: string) =&gt; {
    // every time the viewMode changes, the navigation should be reset as well
    // the dateM variable will contain the navigation and because of the 
    // flatMap it will reset every time the view mode changes
    // if the navigation$ changes afterwards it will manipulate the dateM object
    // by adding months, weeks, or days depending on the viewMode
    const dateM = moment();
    return this.navigation$
        .map((action: number) =&gt; {
            switch (viewMode) {
                case VIEW_MODE.MONTH:
                    return dateM.startOf('month').add(action, "months");
                case VIEW_MODE.WEEK:
                    return dateM.startOf('week').add(action, "weeks");
                case VIEW_MODE.DAY:
                    return dateM.startOf('day').add(action, "days");
            }
            return dateM;
        })
})
currentDate$ = this.currentDateM$.map(dateM =&gt; dateM.toDate());

</code></pre>

<h4 id="currentweek">currentWeek$</h4>

<p>Based on the <code>currentDateM$</code> we can calculate the current week. The <code>currentDateM$</code> is just a moment object of the current date based on the navigation and viewMode.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar8.png" alt="currentWeek$" /></p>

<pre><code class="language-typescript">currentWeek$ = this.currentDateM$.map(dateM =&gt; dateM.week());
</code></pre>

<h4 id="currentmonth">currentMonth$</h4>

<p>Just like we calculated the <code>currentWeek$</code> based on the <code>currentDateM$</code>, we can do the same thing here.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar9.png" alt="currentMonth$" /></p>

<pre><code class="language-typescript">currentMonth$ = this.currentDateM$.map(dateM =&gt; dateM.month());
</code></pre>
<h4 id="currentyear">currentYear$</h4>

<p>Just like we calculated the <code>currentWeek$</code> and the <code>currentMonth$</code> based on the <code>currentDateM$</code>, we can do the same thing here.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar10.png" alt="currentYear$" /></p>

<pre><code class="language-typescript">currentYear$ = this.currentDateM$.map(dateM =&gt; dateM.year());
</code></pre>

<h4 id="filteredappointments">filteredAppointments$</h4>

<p>This is the most important stream. It is used to show the appointments in all the different views, and it is dependent on a bunch of streams:</p>

<ul>
  <li>viewMode$</li>
  <li>currentDateM$</li>
  <li>appointments$</li>
  <li>searchTerm$</li>
</ul>

<p>This looks a bit more complex, but let’s give it a go.</p>

<p><strong>Note:</strong> the <code>[]</code> in the image below stands for an empty array, the <code>[.]</code> for an array with one value, and so on.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/reactivecalendar/reactivecalendar11.png" alt="filteredAppointment$" /></p>

<p>Let’s take the time to process this image. The operator we will use to combine all these streams is called <strong>combineLatest</strong>. It will create a stream that will wait until all streams have a value and will start emitting values for every change of every stream.</p>

<p>So basically, it gives us a function where we have all the information we need. The appointments in Firebase, the view mode, the search term, and the current date. Based on those values, we can calculate the appointments for every view:</p>

<pre><code class="language-typescript">filteredAppointments$ = Observable.combineLatest(
    [this.viewMode$, this.currentDateM$, 
    this.appointments$, this.searchTerm$],
    (viewMode: string, currentDateM: Moment, 
        appointments: Array&lt;Appointment&gt;, searchTerm: string) =&gt; {
        switch (viewMode) {
            // calculate the appointments for the month-view based on
            // the current date, the appointments in firebase 
            // and the searchterm
            case VIEW_MODE.MONTH:
                return appointments
                    .filter(item =&gt; moment(item.date).format('MM/YYYY') === currentDateM.format('MM/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));
             // calculate the appointments for the week-view based on
             // the current date, the appointments in firebase
             // and the searchterm
            case VIEW_MODE.WEEK:
                return appointments
                    .filter(item =&gt; moment(item.date).format('ww/YYYY') === currentDateM.format('ww/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));
            // calculate the appointments for the day-view based on
            // the current date, the appointments in firebase
            // and the searchterm
            case VIEW_MODE.DAY:
                return appointments
                    .filter(item =&gt; moment(item.date).format('DD/MM/YYYY') === currentDateM.format('DD/MM/YYYY'))
                    .filter(item =&gt; this.filterByTerm(item, searchTerm));

        }
    });

private filterByTerm(appointment: Appointment, term: string): boolean {
    return appointment.description.toLowerCase().indexOf(term.toLowerCase()) &gt; -1;
}
</code></pre>

<p>This is all we have to do in order to create a kick-ass realtime reactive calendar application. We have created it in no time and with only a few lines of code. If we think about it, we will soon realize that all corner cases have been covered.</p>

<h2 id="performance-improvements">Performance Improvements</h2>

<p>The complete component looks like the code snippet below now. The calendar should be completely functional in your browser.</p>

<pre><code class="language-typescript">import { Component } from '@angular/core';
import { VIEW_MODE } from '../../constants';
import * as moment from 'moment';
import { Appointment } from '../../types/appointment.type';
import { AngularFireDatabase } from 'angularfire2/database';
import { Observable } from 'rxjs/Observable';
import Moment = moment.Moment;
import { BehaviorSubject } from 'rxjs/BehaviorSubject';


@Component({
    selector: 'app-root',
    template: `
        &lt;topbar
                (next)="onNext()"
                (previous)="onPrevious()"
                (setViewMode)="onSetViewMode($event)"
                (searchChanged)="onSearchChanged($event)"&gt;
        &lt;/topbar&gt;
        &lt;div [ngSwitch]="viewMode$|async"&gt;
            &lt;day-view
                    *ngSwitchCase="VIEW_MODE.DAY"
                    [appointments]="filteredAppointments$|async"
                    [date]="currentDate$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/day-view&gt;
            &lt;week-view
                    *ngSwitchCase="VIEW_MODE.WEEK"
                    [appointments]="filteredAppointments$|async"
                    [year]="currentYear$|async"
                    [week]="currentWeek$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/week-view&gt;
            &lt;month-view
                    *ngSwitchCase="VIEW_MODE.MONTH"
                    [month]="currentMonth$|async"
                    [year]="currentYear$|async"
                    [appointments]="filteredAppointments$|async"
                    (removeAppointment)="onRemoveAppointment($event)"
                    (addAppointment)="onAddAppointment($event)"
                    (updateAppointment)="onUpdateAppointment($event)"
            &gt;
            &lt;/month-view&gt;
        &lt;/div&gt;
    `,
    styleUrls: ['./app.component.less']
})
export class AppComponent {
    VIEW_MODE = VIEW_MODE;
    viewMode$ = new BehaviorSubject(VIEW_MODE.MONTH);
    // 0--------(+1)----(+1)----(-1)-------------...
    navigation$ = new BehaviorSubject&lt;number&gt;(0);
    searchTerm$ = new BehaviorSubject('');

    // -----MONTH---------------------YEAR------...
    // -----MONTH-------------------------------...
    // -----(d)---------------------------------...
    // --------(+1)----(+1)----(-1)-------------...
    // -----d---d-------d-------d-----d----------...

    private currentDateM$ = this.viewMode$.flatMap((viewMode: string) =&gt; {
        let dateM = moment();
        return this.navigation$
            .map((action: number) =&gt; {
                switch (viewMode) {
                    case VIEW_MODE.MONTH:
                        return dateM.startOf('month').add(action, 'months');
                    case VIEW_MODE.WEEK:
                        return dateM.startOf('week').add(action, 'weeks');
                    case VIEW_MODE.DAY:
                        return dateM.startOf('day').add(action, 'days');
                }
                return dateM;
            })
    });

    currentDate$ = this.currentDateM$.map(dateM =&gt; dateM.toDate());
    currentYear$ = this.currentDateM$.map(dateM =&gt; dateM.year());
    currentMonth$ = this.currentDateM$.map(dateM =&gt; dateM.month());
    currentWeek$ = this.currentDateM$.map(dateM =&gt; dateM.week());
    appointments$ = this.db.list('/appointments');
    filteredAppointments$ = Observable.combineLatest([this.viewMode$, this.currentDateM$, this.appointments$, this.searchTerm$],
        (viewMode: string, currentDateM: Moment, appointments: Array&lt;Appointment&gt;, searchTerm: string) =&gt; {
            switch (viewMode) {
                case VIEW_MODE.MONTH:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('MM/YYYY') === currentDateM.format('MM/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));
                case VIEW_MODE.WEEK:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('ww/YYYY') === currentDateM.format('ww/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));
                case VIEW_MODE.DAY:
                    return appointments
                        .filter(item =&gt; moment(item.date).format('DD/MM/YYYY') === currentDateM.format('DD/MM/YYYY'))
                        .filter(item =&gt; this.filterByTerm(item, searchTerm));

            }
        });

    constructor(private db: AngularFireDatabase) {
    }

    private filterByTerm(appointment: Appointment, term: string): boolean {
        return appointment.description.toLowerCase().indexOf(term.toLowerCase()) &gt; -1;
    }

    onSetViewMode(viewMode: string): void {
        this.viewMode$.next(viewMode);
    }

    onPrevious(): void {
        this.navigation$.next(-1);
    }

    onNext(): void {
        this.navigation$.next(1);
    }

    onSearchChanged(e: string): void {
        this.searchTerm$.next(e);
    }

    onRemoveAppointment(id: string): void {
        this.appointments$.remove(id);
    }

    onAddAppointment(date: Date): void {
        this.appointments$.push(new Appointment(date.toDateString(), ''));
    }

    onUpdateAppointment(appointment: Appointment): void {
        this.db.object('appointments/' + appointment.$key).set({
            description: appointment.description,
            date: appointment.date
        });
    }
}

</code></pre>

<p>There is only one problem. We use the same observables multiple times in our template. Since observables are cold by default, they will get executed every time there is a subscription. In Angular, this means a subscription for every async pipe. For performance reasons, we only want to recalculate these streams when something actually changes. For that purpose, we can try to use the <code>share()</code> operator from RxJS. The <code>share()</code> operator is an alias for <code>publish().refCount()</code> and will share the subscription.</p>

<p>However, that creates some problems with Angular and its async pipe.
The situation of the problem goes like this:</p>

<ul>
  <li>Since we are using BehaviorSubjects, the streams will get an initial value (which is what we want, of course).</li>
  <li>The share() operator will emit that value on the first subscription</li>
  <li>When the app is initialized, the async pipes will start subscribing to the stream.</li>
  <li>Because the first async pipe triggered the first emit the rest of the async pipes will miss that value.</li>
</ul>

<p><strong>Solution: shareReplay() will emit those values but keep track of them. That way, the async pipes will never miss a value.</strong></p>

<h2 id="conclusion">Conclusion</h2>

<p>We have created a completely reactive calendar that is performant and fixes a bunch of corner cases in only a few lines of code. Just by thinking about source streams and presentational streams, it wasn’t even that hard. I hope that I can encourage more people to take on this reactive approach and start writing kick-ass applications.</p>

<h2 id="special-thanks">Special Thanks</h2>

<p>I would like to give special thanks to the awesome people that reviewed this post and gave me pointers:</p>

<ul>
  <li>Dominic Elm (<a href="https://twitter.com/elmd_">@elmd_</a>)</li>
  <li>Manfred Steyer (<a href="https://twitter.com/manfredsteyer">@manfredsteyer</a>)</li>
  <li>David Müllerchen (<a href="https://twitter.com/webdave_de">@webdave_de</a>)</li>
  <li>Maxim Robert (<a href="https://twitter.com/sizerone">@sizerOne</a>)</li>
</ul>

<p>Thanks, guys! It means a lot!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Infinite scroll in Angular an RxJS</title>
	  <link>//infinite-scroll-with-rxjs-and-angular2/</link>
	  <author></author>
	  <pubDate>2016-12-21T00:00:00+00:00</pubDate>
	  <guid>//infinite-scroll-with-rxjs-and-angular2/</guid>
	  <description><![CDATA[
	     <h2 id="about-this-article">About this article</h2>

<p>This article explains how the “reactive-programming” approach helps us to create an awesome <strong>infinite-scroll-list</strong> in only a few lines of code. For this article, we are going to use <a href="http://reactivex.io/rxjs/">RxJS</a> and <a href="http://angular.io">Angular</a>. If <a href="http://reactivex.io/rxjs/">RxJS</a> is completely new, it might be a good idea to read the documentation first. Whether we use <a href="http://angular.io">Angular</a> or something else like <a href="https://facebook.github.io/react/">React</a>, it shouldn’t really interfere with the clarity of this article.</p>

<h2 id="reactive-programming">Reactive programming</h2>

<p>Reactive programming is a rather old but very powerful approach of solving problems. However, we can run into problems when trying to think in a completely reactive manner. Thinking reactively is a huge mind switch that we must make to completely accept this “new” way of coding things. The whole “Our application reacts to a state-management-layer like <a href="http://redux.js.org/">redux</a>” principle is grasped quite quickly (it’s reactive programming too), but when it comes to <a href="http://freecontent.manning.com/reactive-fundamentals-thinking-in-streams/">thinking in streams</a> it can become quite difficult in the beginning.</p>

<h3 id="why-reactive-programming">Why reactive programming?</h3>

<p>Reactive programming has some advantages over imperative programming.</p>

<ul>
  <li>No more “if this, then that” scenario’s</li>
  <li>We can forget about a ton of edge-cases&lt;</li>
  <li>It’s easy to separate presentation logic from other logic (The presentation layer will just react to streams)</li>
  <li>It’s a standard: widely supported by tons of languages</li>
  <li>When we grasp the concepts, we write complex logic in a few lines of code in a very simple manner</li>
</ul>

<p>A few days back a colleague of mine came to me with this problem: He wanted to create an <strong>infinite-scroll in Angular</strong> but he had bumped into the  boundaries of imperative programming. It turned out that an infinite-scroll-solution was actually a great use-case to explain how reactive programming can help you write better code.</p>

<h2 id="the-infinite-scroll">The infinite scroll</h2>

<h3 id="what-should-it-do">What should it do?</h3>

<p>An infinite-scroll-list, is a list where the data is being loaded asynchronosly when the user scrolls further down the application. It’s a great way to avoid a pager (where the user had to click on every time) and it can really keep the application performant. It’s an efficient way to keep bandwidth low and increase the user-experience.</p>

<p>For this scenario, let’s say that every page contains 10 results and that all the pages with results are being shown as one long scrollable list =&gt; the infinite-scroll-list.</p>

<p>Let’s list the features of what our infinite-scroll-list must do:</p>

<ul>
  <li>It should load the first page by default</li>
  <li>When the results of the first page don’t fill the page completely, it should fill page 2, and so on, until the page is full</li>
  <li>When the user scrolls down, it should load page 3, and so on…</li>
  <li>When the user resizes it’s window, and more space is being freed for results, it should load the next page</li>
  <li>It should make sure that it doesn’t load the same pages more than once (caching)</li>
</ul>

<h2 id="lets-draw-it-first">Let’s draw it first</h2>

<p>Like most coding decisions, drawing them on a whiteboard first might be a good idea. That might be a personal approach, but it helps us not to write code that will be removed/refactored later.</p>

<p>Based on the feature-list, there are three actions that will trigger the application to load data: Scrolling, resizing, and a manual action that will be triggered to manually fetch pages. When thinking reactively we can see 3 sources of events happening, let’s call them streams:</p>

<ul>
  <li>A stream of scroll events: <strong>scroll$</strong></li>
  <li>A stream of resize events: <strong>resize$</strong></li>
  <li>A manual stream where we can manually decide what page to load: <strong>pageByManual$</strong></li>
</ul>

<p><strong>Note: We will suffix the streams with $ to indicate that they are streams, this is a convention (personal preference)</strong></p>

<p>Let’s draw these streams on a whiteboard:
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard1.png" alt="Whiteboard 1" /></p>

<p>These streams would contain certain values over time:
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard2.png" alt="Whiteboard 2" /></p>

<p>The scroll$ stream has Y values, which we can use to calculate the page number.</p>

<p>The resize$ stream has event values. We don’t need the values but we do need to know when the user resizes its window.</p>

<p>The pageByManual$ will contain page numbers, which we can set directly since this is a subject (more on that later).</p>

<p>What if we could map all these streams, to streams that would contain page numbers? That would be awesome, because based on the page number, we could load a specific page. How we map the current streams to page number-streams is not something that we need to think about right now (we are just drawing remember?).
The next drawing might look something like this:</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard3.png" alt="Whiteboard 3" /></p>

<p>We can see that we have created the following streams based on our initial streams:</p>

<ul>
  <li><strong>pageByScroll$</strong>: which contains page numbers based on the scroll-events</li>
  <li><strong>pageByResize$</strong>: which contains page numbers based on the resize-events</li>
  <li><strong>pageByManual$</strong>: which contains page numbers based on manual events (for instance, if there is still whitespace on the screen, we have to load the next page)</li>
</ul>

<p>What if we could merge these 3 page-number streams in an efficient manner, than we would get a new stream called <strong>pageToLoad$</strong>, that would contain page numbers created by scrolling-events, resize-events, and manual events.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard4.png" alt="Whiteboard 4" /></p>

<p>If we subscribe to the pageToLoad$ stream and than fetch data from the service, part of our infinite scroll would work. However, we were thinking reactively right? That also means, avoid subscriptions as much as possible… 
We actually need a new stream based on the pageToLoad$ stream that contains the results of our infinite scroll list…</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard5.png" alt="Whiteboard 5" /></p>

<p>Now let’s throw this in one big schema.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/infinite-scroll/whiteboard6.png" alt="Whiteboard 6" /></p>

<p>As we can see above we have 3 input streams: one for scrolling, one for resizing and a manual one.
Afterwards we have 3 page streams that are based on the input streams. When merging these streams we can create a pageToLoad$ stream. Based on that pageToLoad$ stream, we will fetch the data.</p>

<h2 id="lets-code">Let’s code</h2>

<p>We have drawn more than enough, we have a clear vision of what our inifinte-scroll-list should do, so let’s start shall we?</p>

<p>To calculate which page needs to be loaded we need 2 properties:</p>

<pre><code class="language-typescript">private itemHeight = 40;
private numberOfItems = 10;// number of items in a page
</code></pre>

<h3 id="pagebyscroll">pageByScroll$</h3>

<p>The pageByScroll$ stream might look something like this:</p>

<pre><code class="language-typescript"> private pageByScroll$ = 
 	// first of all, we want to create a stream that contains 
 	// all the scroll events that are happening in the window object
	Observable.fromEvent(window, "scroll") 
	// we are only interested in the scrollY value of these events
	// let's create a stream with only these values
	.map(() =&gt; window.scrollY)
	// create a stream with the filtered values
	// we only need the values from when we are scrolling outside
	// our viewport
	.filter(current =&gt; current &gt;=  document.body.clientHeight - window.innerHeight)
	// Only when the user stops scrolling for 200 ms, we can continue
	// so let's debounce this stream for 200 ms
	.debounceTime(200) 
	// filter out double values
	.distinct() 
	// calculate the page number
	.map(y =&gt; Math.ceil((y + window.innerHeight)/ (this.itemHeight * this.numberOfItems)));
	
	// --------1---2----3------2...
</code></pre>

<p><strong>note: In real applications you might want to use injected services for window and document</strong></p>

<h3 id="pagebyresize">pageByResize$</h3>

<p>The pageByResize$ looks like this:</p>

<pre><code class="language-typescript">  private pageByResize$ = 
  	// Now, we want to create a new stream that contains 
 	// all the resize events that are happening in the window object
	Observable.fromEvent(window, "resize")
	// when the user stops resizing for 200 ms, then we can continue
	.debounceTime(200) 
	// calculate the page number based on the window
   .map(_ =&gt; Math.ceil(
	   	(window.innerHeight + document.body.scrollTop) / 
	   	(this.itemHeight * this.numberOfItems)
   	));
   
	// --------1---2----3------2...
</code></pre>

<h3 id="pagebymanual">pageByManual$</h3>

<p>The pageByManual$ is the stream we use to have an initial value (initial page to load), but it’s also something that we need to control manually. A <a href="http://reactivex.io/documentation/subject.html">Behavior subject</a> looks perfect for the job, because we need a stream that has an initial value where we can also manually add values. A behavior subject is just a stream that has an initial value and can be manipulated over time.</p>

<pre><code class="language-typescript">private pageByManual$ = new BehaviorSubject(1);

// 1---2----3------...
</code></pre>

<h3 id="pagetoload">pageToLoad$</h3>

<p>Awesome, we have the 3 streams with page inputs, now let’s create a pageToLoad$ stream.</p>

<pre><code class="language-typescript">private pageToLoad$ = 
	// merge all the page streams and create a new stream of those
	Observable.merge(this.pageByManual$, this.pageByScroll$, this.pageByResize$)
	// create a new stream where the double values are filtered out
	.distinct() 
	// check if the page is already in the cache (just an array property in our component)
	.filter(page =&gt; this.cache[page-1] === undefined); 
</code></pre>

<h3 id="itemresults">itemResults$</h3>

<p>The hard part is over. We now have a stream with the page we have to load in there, which is super useful. We don’t need to care anymore about corner cases or other complex logic. Every time a new value in that stream is added, we just need to load the data. <strong>That’s it!!</strong></p>

<p>We will use <a href="http://reactivex.io/documentation/operators/flatmap.html">flatmap</a> for this because the fetch-data-call will return a stream as well. FlatMap (or MergeMap) will merge these 2 streams as one.</p>

<pre><code class="language-typescript">itemResults$ = this.pageToLoad$ 
	// based on that stream, load our asynchronosly data
	// flatmap is an alias for mergemap
	.flatMap((page: number) =&gt; {
		// load me some starwars characters
		return this.http.get(`https://swapi.co/api/people?page=${page}`)
			// create a stream that contains the results
			.map(resp =&gt; resp.json().results)
			.do(resp =&gt; {
				// add the page to the cache
				this.cache[page -1] = resp;
				// if the page contains enough white space, load some more data :)
				if((this.itemHeight * this.numberOfItems * page) &lt; window.innerHeight){
					this.pageByManual$.next(page + 1);
				}
			})
		})
	// eventually, just return a stream that contains the cache
	.map(_ =&gt; flatMap(this.cache)); 
</code></pre>

<h3 id="the-result">The result</h3>

<p>the complete result might look like this:  <strong>Note the <a href="https://angular.io/docs/ts/latest/guide/pipes.html#!#async-pipe">async pipe</a> that puts the whole subscription process into play</strong></p>

<pre><code class="language-typescript">@Component({
  selector: 'infinite-scroll-list',
  template: `
  &lt;table&gt;
   &lt;tbody&gt;
    &lt;tr *ngFor="let item of itemResults$|async" [style.height]="itemHeight + 'px'"&gt;
      &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
   &lt;/tbody&gt;
   &lt;/table&gt;
  `
})
export class InfiniteScrollListComponent {
  private cache = []; 
  private pageByManual$ = new BehaviorSubject(1);
  private itemHeight = 40;
  private numberOfItems = 10; 
  private pageByScroll$ = Observable.fromEvent(window, "scroll")
      .map(() =&gt; window.scrollY)
      .filter(current =&gt; current &gt;=  document.body.clientHeight - window.innerHeight)
      .debounceTime(200) 
      .distinct() 
      .map(y =&gt; Math.ceil((y + window.innerHeight)/ (this.itemHeight * this.numberOfItems)));
       
  private pageByResize$ = 
	Observable.fromEvent(window, "resize")
	.debounceTime(200) 
	.map(_ =&gt; Math.ceil(
	   	(window.innerHeight + document.body.scrollTop) / 
	   	(this.itemHeight * this.numberOfItems)
   	));

    
  private pageToLoad$ = Observable
    .merge(this.pageByManual$, this.pageByScroll$, this.pageByResize$)
    .distinct() 
    .filter(page =&gt; this.cache[page-1] === undefined); 
    
  itemResults$ = this.pageToLoad$ 
    .do(_ =&gt; this.loading = true)
    .flatMap((page: number) =&gt; {
      return this.http.get(`https://swapi.co/api/people?page=${page}`)
          .map(resp =&gt; resp.json().results)
      		.do(resp =&gt; {
				this.cache[page -1] = resp;
				if((this.itemHeight * this.numberOfItems * page) &lt; window.innerHeight){
					this.pageByManual$.next(page + 1);
				}
          })
    })
    .map(_ =&gt; flatMap(this.cache)); 
  
  constructor(private http: Http){ 
  } 
}
</code></pre>

<p>Here is a <a href="http://plnkr.co/edit/WewXnQRj9xBA7yPveWLQ?p=preview">working plunk</a></p>

<iframe src="https://embed.plnkr.co/plunk/WewXnQRj9xBA7yPveWLQ?show=app,preview&amp;deferRun" frameborder="0" width="100%" height="480px">
</iframe>

<p>Again, (like I try to prove in previous articles) We don’t need to use third party solutions for everything. The infinite-scroll-list doesn’t contain that much code, and it’s very flexible.
Let’s say that we would like to free up DOM-elements and use only 100 items at a time, we could just create a new stream for that :)</p>

<p>Thanks for reading, I hope you enjoyed it.</p>

	  ]]></description>
	</item>

	<item>
	  <title>How share() can reduce network requests</title>
	  <link>//how-share()-can-reduce-network-requests/</link>
	  <author></author>
	  <pubDate>2016-12-20T00:00:00+00:00</pubDate>
	  <guid>//how-share()-can-reduce-network-requests/</guid>
	  <description><![CDATA[
	     <p>As you hopefully all know, observables you get back from the Angular 2 Http service are cold. A cold observable only starts when you subscribe to to it and is unicast (for every subscription to the Http observable, a network call is triggered).</p>

<p><strong>Note:</strong> If you want to dive deeper into hot vs cold observables, Christoph Burgdorf from Thoughtram wrote <a href="http://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html" target="_blank">an awesome article </a> on the subject (Rx pun intended :)).</p>

<h4 id="project-setup">Project setup</h4>

<p>To demonstrate how the <code>share()</code> operator can reduce our number of network calls, I’ve created a demo application (code available on <a href="https://github.com/KwintenP/save-netwerk-requests-with-share" target="_blank">Github</a>). The setup looks like this:</p>

<p><img src="https://www.dropbox.com/s/d87po1zbp2ri11u/Screenshot%202016-12-15%2020.08.33.png?raw=1" alt="setup" /></p>

<p>As you can see, we have an app component, which is smart, and three dumb components. During startup, the app component will randomly fetch one of the Star Wars characters by calling the StarWarsService.</p>

<pre><code class="language-typescript">// app.component.ts
this.character$ =
     this.starWarsService.getCharacter(this.generateNumber());
</code></pre>

<p>The StarWarsService uses Angular’s Http and returns a character from the series using the swapi.co API.</p>

<pre><code class="language-typescript">// star-wars.service.ts
public getCharacter(id: number): Observable&lt; StarWarsCharacter &gt; {
    return this.http.get('https://swapi.co/api/people/' + id)
      .map((response: Response) =&gt; response.json());
}
</code></pre>

<p>The app component creates three new observables by mapping the <code>character$</code> source observable.</p>

<pre><code class="language-typescript">// app.component.ts
this.name$ = this.character$.map(character =&gt; character.name);
this.birthDate$ = this.character$.map(character =&gt; character.birth_year);
this.gender$ = this.character$.map(character =&gt; character.gender);
</code></pre>

<p>The data is passed to the dumb components using the <code>async</code> pipe.</p>

<pre><code class="language-html">&lt;app-character-name [name]="name$ | async"&gt;
&lt;/app-character-name&gt;
&lt;app-character-birthdate [birthDate]="birthDate$ | async"&gt;
&lt;/app-character-birthdate&gt;

&lt;button type="button" (click)="toggleEnabled()"&gt;
     Enable gender component
&lt;/button&gt;
&lt;app-character-gender *ngIf="enabled" [gender]="gender$ | async"&gt;
&lt;/app-character-gender&gt;
</code></pre>

<p>As you can see in the snippet above, the gender component is only rendered <strong>after</strong> the button has been clicked. This way we can simulate a ‘delayed subscription’. We’ll see why this is important in a second.</p>

<h4 id="potential-pitfall">Potential pitfall</h4>
<p>If we run this code, everything works perfectly. But if we look at the network tab, we can see some strange behaviour.</p>

<p><img src="https://www.dropbox.com/s/j5etmgqz668v4wp/Dec-15-2016%2020-00-10.gif?raw=1" alt="setup" /></p>

<p>When the page is refreshed, we already see two calls to the backend. If we click the button to enable the gender component, we see another request being send. Why do we see multiple backend requests if we’re only asking for one <code>character$</code>?</p>

<p>The reason is simple. The <code>character$</code> is a <strong>cold observable</strong>. If you subscribe to a cold http observable twice, you’ll have two backend requests.
We map this <code>character$</code> or source observable using the <code>map</code> operator to three different observables. Every subscription to one of these three observables (which is done by the async pipe), is basically the same as subscribing to the <code>character$</code> observable directly. And because the <code>character$</code> observable is a cold observable, you see multiple requests.
The problem with this is that the underlying subscription to the source observable is <strong>not shared</strong>.</p>

<h4 id="how-can-we-fix-this-kind-of">How can we fix this (kind of)</h4>

<p>Let’s change the observable that the StarWarsService returns like this:</p>

<pre><code class="language-typescript">return this.http.get('https://swapi.co/api/people/' + id)
      .map((response: Response) =&gt; response.json())
      .share();
</code></pre>

<p>We added the <code>share()</code> operator. This is an alias for doing <code>publish().refCount()</code>. This will make the <code>character$</code> a hot observable that starts emitting events as soon as the first one subscribes. The <code>character$</code> observable will be a ‘shared’ one. Let’s first see what this means and explain afterwards:</p>

<p><img src="https://www.dropbox.com/s/o3i03kudmutt1gk/Dec-15-2016%2019-57-47.gif?raw=1" alt="setup" /></p>

<p>Now we can see that, on the initial page load, there is only one request. That’s because the <code>share()</code> operator will share the underlying subscription between its listeners. As soon as the first one subscribes, it will listen to the Http observable and thus trigger one backend request. Everybody else who starts listening afterwards, will get the same result. Hence we only see a single request to the swapi.co API.</p>

<p>But, when I click on the button to enable the gender component, we can see that a second request is triggered. This means our <code>share()</code> operator doesn’t help us entirely. It turns out that with <code>share()</code>, if the source observable completes, the underlying subscription is gone as well. So when the gender component gets rendered, the original request is long finished and completed. For every new subscription after this completion, in our case via the <code>gender$</code> observable, the <code>share()</code> operator will start a new backend request.</p>

<p>This can perfectly be expected behaviour, if you want it. In some cases though, you don’t.</p>

<h4 id="publishreplay-to-the-rescue">publishReplay to the rescue</h4>

<p>Let’s change the observable from the StarWarsService one more time:</p>

<pre><code class="language-typescript">let obs$: ConnectableObservable&lt;StarWarsCharacter&gt; =
     this.http.get('https://swapi.co/api/people/' + id)
         .map((response: Response) =&gt; response.json())
         .publishReplay();
obs$.connect();
return obs$;
</code></pre>

<p>I removed the <code>share()</code> operator and used <code>publishReplay()</code> instead. This will return an observable that will subscribe to the source observable as soon as you <code>connect()</code> it. In our case, this needs to happen immediately, so I call it before returning.
Let’s see what this does:</p>

<p><img src="https://www.dropbox.com/s/5j4381vj8439dbb/Dec-15-2016%2019-55-20.gif?raw=1" alt="setup" /></p>

<p>Alright! Now we only have one request at startup time and we do not have a new one when we render the gender component. The <code>publishReplay()</code> operator doesn’t care if the Http observable completes or not. For every new subscription, it will just return the previous result.</p>

<h4 id="conclusion">Conclusion</h4>

<ul>
  <li>If your source observable ‘splits’ into multiple observables, using the <code>share()</code> operator will reduce network requests.</li>
  <li>If you have subscriptions which are delayed due to delayed rendering, you might want to use the <code>publishReplay()</code> operator to avoid extra requests.</li>
</ul>

<p><strong>NOTE:</strong> Thanks to <a href="https://twitter.com/juristr">@juristr</a> for the review!</p>


	  ]]></description>
	</item>

	<item>
	  <title>A scalable Angular 2 architecture</title>
	  <link>//A-scalable-angular2-architecture/</link>
	  <author></author>
	  <pubDate>2016-11-09T00:00:00+00:00</pubDate>
	  <guid>//A-scalable-angular2-architecture/</guid>
	  <description><![CDATA[
	     <h2 id="foreword">Foreword</h2>

<p>This article might be more relevant for <a href="http://angular.io">Angular 2</a> developers, but I believe it can be used with other frameworks as well. It’s just a handbook for writing scalable and maintainable single-page-applications. It’s important to note, that this is not the only way, but it’s a way that works for me in quite a few situations.</p>

<h3 id="writing-scalable-single-page-apps">Writing scalable Single-page-apps</h3>

<p>A lot of developers are having trouble writing large-scale, maintainable single-page-applications. This results in early technical debt, a lot of frustration when fixing bugs, an eternal struggle when writing unit tests and creating reusable chunks of code…</p>

<p>One of the biggest challenges might be: extending existing logic and writing new features based on a tricky foundation.</p>

<p>Single-page-applications are rather new, and especially older frameworks gave you 100 different ways to design an application. There wasn’t any structure, encapsulation and everything was tightly coupled to each other.</p>

<p>Most of the time in the beginning of a project the development process went blazingly fast. But after a few developers, features, refactors, the code started to become less maintainable. It started to look like spaghetti. Frameworks have matured a lot, but it’s also important that the architecture of the software you write matures along with the process.</p>

<h2 id="spa-in-2016-and-even-before">SPA in 2016 (and even before)</h2>

<p>To explain the architecture where this article is all about, here’s a reminder of how a web-application in 2016 might look like.
These are concepts that your applications should rely on these days. It doesn’t matter whether using <a href="https://facebook.github.io/react/">React</a>, <a href="http://angular.io">Angular 2</a> or something else. These principles exist to make sure that your web architecture becomes maintainable.</p>

<h3 id="principle-1-components">Principle 1: Components</h3>

<p>SPA-technologies like React and Angular2 make us use components. A component is a piece of HTML and JavaScript combined. We don’t want to use standalone views or standalone controllers anymore.
They can grow exponentially and are related to each other in a way that is hard to maintain.</p>

<p>So basically the philosophy here is:
<strong>everything should be a component</strong>, even your pages and your application. An application could look like this:</p>

<pre><code class="language-html">&lt;application&gt;
	&lt;navbar fullname="Brecht Billiet" logout="logMeOut()"&gt;
	&lt;/navbar&gt;
	&lt;users-page&gt;
		...
		&lt;grid data="users"&gt;
		&lt;/grid&gt;
		...
	&lt;/users-page&gt;
&lt;/application&gt;
</code></pre>

<p>Some very simple but very important tips in designing components:</p>
<ul>
<li>Keep them as small as possible</li>
<li>Keep them as dumb as possible</li>
</ul>

<p>If you are new to designing components, this article might be of help: <a href="http://blog.brecht.io/components-demystified">components demystified</a></p>

<p><strong>Note:</strong> Smart components are also called structural components, containers or stateful components</p>

<h3 id="principle-2-unidirectional-dataflow">Principle 2: Unidirectional dataflow</h3>

<p>Before, we used to update application state in a rather inefficient manner:</p>
<ul>
<li>We tried to make sibling components communicate with each other</li>
<li>Parent components tried to notify child components with actions</li>
<li>We tried to send events between different components</li>
<li>We used one-way binding, two-way binding</li>
<li>We injected models everywhere to share pieces of state</li>
</ul>

<p>Did you ever tried to make sibling components communicate with each other?
Sometimes it seems pragmatic to do so, but please don’t.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/scalableng2architecture/multidirectionaldataflow.png" alt="Multidirectional dataflow" /></p>

<p><strong>This is bad design!</strong> It’s almost impossible to see in which direction the data flows. I’s also very hard to maintain this code, fix bugs in it or develop features.
What we do want, is a unidirectional dataflow like <a href="https://facebook.github.io/flux/">Flux</a> or <a href="http://redux.js.org/">Redux</a>.</p>

<p>It basically looks like this: child components only notify their parent components, the parent (smart component) will send an action to a store that contains state, and that action will update the state for the entire application. When that state is being updated, we can re-evaluate the component tree. As a result the data always flows in the same direction (downwards).</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/scalableng2architecture/unidirectionaldataflow.png" alt="Unidirectional dataflow" /></p>

<p>The big advantages of this approach are:</p>
<ul>
<li>Decoupling components from each other</li>
<li>Maintainability</li>
<li>The switch to real-time is much smaller, because the software is reactive</li>
<li>We can actually see what's going on by monitoring the actions</li>
</ul>

<p>If you are new to unidirectional dataflows checkout the <a href="http://redux.js.org/docs/introduction/">introduction to redux</a> and the part about <a href="http://redux.js.org/docs/basics/DataFlow.html">unidirectional dataflow</a>.</p>

<h2 id="a-scalable-architecture">A scalable architecture</h2>

<p>I designed a certain architecture based on principles of today (most of them explained above) and even principles from 10 years back. Would I say it’s the way to go for every SPA? Not at all… Every type of software deserves its own architecture, and I’m just showing a concept that works for me in a lot of scenarios. This architecture might come in handy for developers that are writing <a href="http://angular.io">Angular 2</a> where we can profit from awesome features like dependency injection, but it can also be applied in other frameworks.</p>

<h3 id="abstraction-that-makes-sense">Abstraction that makes sense</h3>

<p>This principle is partially based on the <a href="http://www.slideshare.net/nzakas/scalable-javascript-application-architecture">Sandbox principle</a> of <a href="https://twitter.com/slicknet">Nicholas Zakas</a>, which is already a few years old. For Nicholas Zakas, the sandbox acts like a dispatcher between different modules where a module is like a smart component.
In that architecture, there was no unidirectional dataflow though.
For me a sandbox is a way to <strong>decouple the presentation layer from the application logic</strong>, but that’s not its only responsibility.</p>

<p>But let’s start from the beginning…
In this particular scenario I’m going to assume that we use <a href="http://redux.js.org">Redux</a>. However, it doesn’t really matter what kind of state management you use, but it’s important that you know the principle behind it.</p>

<h3 id="rule-number-one-dont-let-your-components-play-with-all-the-toys">Rule number ONE: Don’t let your components play with all the toys</h3>

<p>The same reason you don’t let children play with everything: <strong>“It might get messy”</strong>.
Smart components (also named containers here) should also follow a very strict set of rules. We don’t want to inject every service that we want in there, just because we can. For instance: it might not make sense to inject a game-engine in an authentication module.</p>

<p>The following example shows a big constructor with a lot of dependencies. In this scenario <strong>MyComponent</strong> can pretty much do whatever it wants in the application. It gets injected whatever it wants and uses whatever it wants.
That’s generally not a good idea.</p>

<pre><code class="language-typescript">export class MyComponent{
	constructor(...,private foo:Foo, private bar: Bar, 
		private store: Store&lt;ApplicationState&gt;, private authService: AuthService,
		private fooHttpService: FooHttpService, private barMapper: BarMapper, ...){
	}
}
</code></pre>

<p>The example above has too much dependencies in its constructor. It has to many links to the rest of the application. When you persue this kind of design it might end up looking like this: (The REST stands for restful services, so these are just the HTTP blocks)
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/scalableng2architecture/abstraction_step1.png" alt="Abstraction step1" /></p>

<p>This is starting to look like spaghetti code, where everything is really tightly coupled.
An abstraction layer could really help us here. In the example below we can see that the presentation layer is completely decoupled and the abstraction layer delegates everything.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/scalableng2architecture/abstraction_step2.png" alt="Abstraction step2" /></p>

<p>The abstraction might look something like this:</p>

<pre><code class="language-typescript">export class MyComponent{
	constructor(private abstraction: SomeAbstractionType){
	}
	
	doSomething(): void{
	this.abstraction.doSomething();
}
</code></pre>

<h3 id="rule-number-two-components-should-not-know-about-the-state-management-layer">Rule number TWO: Components should not know about the state management layer</h3>

<p>Dumb components and smart components shouldn’t know that you use Redux, or any other state management layer for that matter. They should not care how state is being managed. They just trust that it’s being handled the right way. It’s not their responsibility. The responsibility of the presentation layer is <strong>“to present”</strong> and <strong>“to delegate”</strong>.</p>

<p>The snippet below might be an example of bad design because the component is very tightly coupled to redux (we use <a href="https://github.com/ngrx/store">ngrx/store</a> in this example)</p>

<pre><code class="language-typescript">export class MyComponent{
	// we just care about the state, not where it comes from...
	users$ = this.store.select(state =&gt; state.users);
	foo$ = this.store.select(state =&gt; state.foo);
	bar$ = this.store.select(state =&gt; state.bar);
	constructor(..., 
		private store: Store&lt;ApplicationState&gt;, ...){
	}
	
	addUser(user: User): void{
		// we don't care about the actiontype, payload or store
		this.store.dispatch({type: ADD_USER, payload: {user}}
	}
	removeUser(userId: string): void{
		// we don't care about the actiontype, payload or store
		this.store.dispatch({type: REMOVE_USER, payload: {userId}}
	}
}
</code></pre>

<p>This might be clearer, and more loosely coupled:</p>

<pre><code class="language-typescript">export class MyComponent{
	users$ = this.facade.users$;
	foo$ = this.facade.foo$;
	bar$ = this.facade.bar$;
	
	constructor(private facade: ...){
	}
	
	addUser(user: User): void{
		this.facade.addUser(user);
	}
	removeUser(userId: string): void{
		this.facade.removeUser(userId)
	}
}
</code></pre>

<p>Now the component really focusses on its responsibility. It doesn’t know how the user will be added or removed, it doesn’t know who populates the users$-stream, foo$-stream and bar$-stream. It gives that responsibility to its abstraction layer. Right now, the presentation layer is completely decoupled from the rest of the application. Which brings the following advantages</p>

<ul>
<li>We finally have encapsulation</li>
<li>Easier to test, we only have to mock the abstraction layer</li>
<li>If the abstraction layer keeps its API, it can be developed in parallel</li>
<li>It reacts on the abstraction layer, so real-time development becomes easy</li>
<li>The presentation layer is not coupled to the rest of the app anymore, so refactoring becomes easier</li>
</ul>

<h3 id="rule-number-three-http-services-should-not-know-about-the-state-management-layer">Rule number THREE: HTTP services should not know about the state management layer</h3>
<p>At a first glance, it might seem pragmatic to handle the result of a GET call and put it in the store right in the service. But the only goal an HTTP service has, is <strong>to perform HTTP requests and return the result of those requests</strong>.
This might look pragmatic:</p>

<pre><code class="language-typescript">export class UserService{
	// expose the users$-stream directly in the service
	users$ = this.store.select(state =&gt; state.users);
	
	constructor(private store: Store&lt;ApplicationState&gt;, private http: Http){
	}
	
	fetchUsers(): void{
		this.http.get("...")
			.map(...)
			.subscribe((users) =&gt; {
				// when successful, put the users in the store
				// is this really my responsibility?
				this.store.dispatch({type: SET_USERS, payload: {users}});
			});
	}
}
</code></pre>

<p>But now our http services are very tightly coupled to our state management system.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/scalableng2architecture/abstraction_step3.png" alt="Abstraction step3" /></p>

<p>This is actually the only responsibility an http service should have.</p>

<pre><code class="language-typescript">export class UserService{
	constructor(private http: Http){
	}
	
	// just let the consumer of this service handle the store interaction
	// this will just return a stream of users
	fetchUsers(): Observable&lt;Array&lt;User&gt;&gt;{
		return this.http.get("...").map(...)
	}
}
</code></pre>

<h3 id="a-possible-solution">A possible solution</h3>
<p>This is not the only solution of course, but it’s a solution that has worked most of the times for me.
Every presentational module has access to its own sandbox. A sandbox is a service that will expose:</p>
<ul>
<li>Streams of state (selected from redux in this case)</li>
<li>Methods of actions that the module (which consumes that sandbox) may execute</li>
</ul>

<p>No <strong>it’s not just a facade</strong> :) It should have a certain amount of logic.</p>
<ul>
<li>Fetching the right pieces of state from the store</li>
<li>Dispatching the correct actions with the correct types and payloads to the store</li>
<li>Delegating to the right services of different modules</li>
<li>Handling [optimistic updates](http://blog.brecht.io/Cancellable-optimistic-updates-in-Angular2-and-Redux/)</li>
<li>If using something like firebase, exposing the correct streams from firebase</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/scalableng2architecture/sandboxes.png" alt="Abstraction Sandboxes" /></p>

<p>The advantages of the sandbox are:</p>
<ul>
<li>Decoupling the presentation layer from the rest</li>
<li>Abstracting away the state management layer</li>
<li>You can see what a module has access to by opening its sandbox</li>
<li>Components cannot just use and break whatever they want, better encapsulation</li>
<li>Putting optimistic update logic in there seems like the right place because neither the component nor the service cares about that functionality</li>
<li>We can switch to a different kind of state management without rewriting services and components</li>
</ul>

<h2 id="summary">Summary</h2>

<p>This architecture is one way of doing things, but that doesn’t mean that it’s the only way.</p>

<p>I do believe it’s very important to have encapsulation, loose-coupling and a decent structure of responsibilities. The frontend landscape evolves quickly, which means that we might want to be flexible for refactors/new technologies.
I hope you enjoyed the article.</p>

<h2 id="want-to-learn-more">Want to learn more?</h2>

<p>Checkout <a href="http://strongbrew.io">strongbrew.io</a> where <a href="http://twitter.com/kwintenp">Kwinten Pisman</a> and <a href="http://twitter.com/brechtbilliet">me</a> are giving a “reactive applications workshop” where we go more into detail on this subject.</p>

<h2 id="a-very-special-thanks">A very special thanks</h2>
<p>I want to thank the people who have reviewed this article and gave me their valuable input. Thank you so much <a href="http://twitter.com/jvandemo">Jurgen Van de Moere</a>, <a href="http://twitter.com/carmenpopoviciu">Carmen Popoviciu</a>, <a href="http://twitter.com/manfredsteyer">Manfred Steyer</a> and <a href="http://twitter.com/juristr">Juri Strumpflohner</a>!!!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Cancellable optimistic updates in Angular 2 and Redux</title>
	  <link>//Cancellable-optimistic-updates-in-Angular2-and-Redux/</link>
	  <author></author>
	  <pubDate>2016-09-23T00:00:00+00:00</pubDate>
	  <guid>//Cancellable-optimistic-updates-in-Angular2-and-Redux/</guid>
	  <description><![CDATA[
	     <p><a href="https://angular.io/">Angular 2</a> and <a href="https://github.com/reactjs/redux">redux</a> are 2 technologies that are getting a lot of traction these days. Angular 2 is a SPA (single-page-app) framework and redux is a state management tool. Most developers that are using Angular 2 are using the <a href="https://github.com/ngrx/store">@ngrx/store</a> variant of the redux principle. Because I’m one of them I will be using @ngrx/store instead of redux.js for this article. Don’t let that bother you, what you are about to read can be used with redux.js in the exact same way. If you have never heard about redux, I strongly advice to read the <a href="http://redux.js.org/">documentation</a> first.</p>

<h2 id="optimistic-updates">Optimistic updates</h2>

<p>Redux has a client-side store that has all the data and state your client-side application needs. Therefore, it is the single source of truth for your frontend. When something in that store changes, your components get updated automatically. Let’s say that we are implementing a winecellar application which will obviously contain an array of wines.</p>

<p><strong>Scenario: we want to remove a wine from the winecellar.</strong></p>

<p>A user goes to the index page of our application, clicks a delete button in the datagrid which will call an angular service to remove a wine. The service does an HTTP call to a server, and when the wine finally gets deleted, the service responds with a 200 response (ok). When that happens we can update the redux store and our view gets updated.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario1.png" alt="Scenario 1" /></p>

<p>The code explained above might look like this:</p>

<pre><code class="language-typescript">remove(wine: Wine): void {
    this.http.delete(`${API_URL}/wines/${wine._id}`).subscribe(() =&gt; {
    	// dispatch the action to the store, when the call was successful
    	this.store.dispatch({type: REMOVE_WINE, payload: {_id: wine._id}});
    });
}
</code></pre>

<p>This is the traditional way of doing things, but I think we can do it better. What if we would update the store, regardless of the HTTP response the server returns? We click the delete button in the datagrid, call the angular service like we already did. But in that service we update the store directly (parallel with the http call)</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario2.png" alt="Scenario 2" /></p>

<p>The code explained above might look like this:</p>

<pre><code class="language-typescript">remove(wine: Wine): void {
	// dispatch directly to the store
	this.store.dispatch({type: REMOVE_WINE, payload: {_id: wine._id}};
	// we still have to subscribe because http calls return cold observables
    this.http.delete(`${API_URL}/wines/${wine._id}`).subscribe();
}
</code></pre>

<p>This is a pretty nice change: Our application has just gotten a lot <strong>faster and snappier</strong>. Every time the user does an action, the store gets updated immediately, which means that the components will get updated immediately as well. We never have to wait for http responses again.</p>

<p>There is one exception to this rule: When <strong>adding</strong> data, the backend has to return an ID which means that for POST calls we will have to postpone the store update until we get a 200 response. (otherwise we would have id-less wines in our store, and we can’t have that)</p>

<h2 id="what-if-the-server-call-fails">What if the server-call fails?</h2>

<p>What if the user’s internet-connection is lost? Or the backend doesn’t return a 200 response but an error. Our store will already be updated, the wine will be lost when it’s in fact still in the database. In some scenarios you want to prevent that kind of behavior. In those cases we want to rollback that specific action, but not interfere with the rest of the actions. It has to be completely safe.</p>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/optimisticupdates/optimisticupdates_scenario3.png" alt="Scenario 3" /></p>

<p>We would like to implement something like this:</p>

<pre><code class="language-typescript">remove(wine: Wine): void {
	// create an action
	let action = {type: REMOVE_WINE, payload: {_id: wine._id}};
	//dispatch the action to the store
	this.store.dispatch(action);
	// call the backend
    this.http.delete(`${API_URL}/wines/${wine._id}`)
    	.subscribe(
    		// on success, do nothing
    		() =&gt; {}, 
	    	// on error, rollback the action
	    	() =&gt; {
	    		this.store.dispatch({type: "UNDO_ACTION", payload: action});
	    	// maybe show somekind of errormessage to show the user that it's action failed
    	});
}
</code></pre>

<p>It turns out that when using the redux pattern, this only takes 12 lines of code (without comments :-)). We will have to create a parent reducer that will delegate to our root reducer. The parent reducer will keep track of all the actions, so they can be rolled back.
The implementation looks like this:</p>

<pre><code class="language-typescript">import {ApplicationState} from "../statemanagement/state/ApplicationState";
import {Action, ActionReducer} from "@ngrx/store";

export function handleUndo(rootReducer: ActionReducer&lt;ApplicationState&gt;)
	: ActionReducer&lt;ApplicationState&gt; {
	// keep the executedActions
    let executedActions: Array&lt;Action&gt; = [];
    return (state: ApplicationState, action: Action) =&gt; {
        if (action.type === "UNDO_ACTION") {
        	// if the action is UNDO_ACTION, 
        	// then call all the actions again on the rootReducer, 
        	// except the one we want to rollback
            let newState: any = {};
            executedActions = executedActions.filter(eAct =&gt; eAct !== action.payload);
            // update the state for every action untill we get the
            // exact same state as before, but without the action we want to rollback
            executedActions.forEach(executedAction =&gt; 
            	newState = rootReducer(newState, executedAction));
            return newState;
        }
        // push every action that isn't an UNDO_ACTION to the executedActions property
        executedActions.push(action);
        // just delegate
        return rootReducer(state, action);
    };
}
</code></pre>

<p>So basically, when an action is being rolled back, every action that has been taken before is being executed on a piece of state again. When that piece of state is updated, it will return it and the store will be updated with the same state, except the one that our rolled back action created.</p>

<p>To make sure the actions can be undone, we have to make redux use the piece of code above. This is how you could use it in Angular 2.</p>

<pre><code class="language-typescript">@NgModule({
	// instead of passing the rootReducer directly
	// like we would have done before, wrap it in the handleUndo function
    imports: [StoreModule.provideStore(handleUndo(rootReducer))/*, ...*/],
    /* ... */
})
export class AppModule {
}
</code></pre>

<h2 id="possible-improvements">Possible improvements</h2>

<p>Won’t it become slow after a while, replaying all these actions?
Some facts:</p>
<ul>
<li>Actions are very cheap</li>
<li>They will update the store only once, we execute the actions ourselves, so ui won't get updated</li>
<li>Actions only get replayed when there is an error</li>
<li>The devtools also work like that, enables [timetraveling](https://onsen.io/blog/react-redux-devtools-with-time-travel)</li>
</ul>
<p>What if it would become slow?
We can implement a buffer. Let’s say that we only want the last 100 actions to be kept.</p>

<pre><code class="language-typescript">export function handleUndo(rootReducer: ActionReducer&lt;ApplicationState&gt;, 
	bufferSize = 100): ActionReducer&lt;ApplicationState&gt; {
    let executedActions: Array&lt;Action&gt; = [];
    let initialState = undefined;
    return (state: ApplicationState, action: Action) =&gt; {
        if (action.type === "UNDO_ACTION") {
        	// if the action is UNDO_ACTION, 
        	// then call all the actions again on the rootReducer, 
        	// except the one we want to rollback
            let newState: any = initialState;
            executedActions = executedActions.filter(eAct =&gt; eAct !== action.payload);
            // update the state for every action untill we get the
            // exact same state as before, but without the action we want to rollback
            executedActions.forEach(executedAction =&gt; 
            	newState = rootReducer(newState, executedAction));
            return newState;
        }
       	// push every action that isn't an UNDO_ACTION to the executedActions property
		executedActions.push(action);
        let updatedState =  rootReducer(state, action);
        if (executedActions.length === bufferSize + 1) {
            let firstAction = executedActions[0];
            // calculate the state x (buffersize) actions ago
            initialState = rootReducer(initialState, firstAction);
            // keep the correct actions
            executedActions = executedActions.slice(1, bufferSize + 1);
        }
        return updatedState;
    };
}
</code></pre>

<h3 id="conclusion">Conclusion</h3>
<p>The redux pattern has opened amazing doors for frontend development. Just like <a href="http://blog.brecht.io/How-we-made-our-app-real-time-in-6-lines-of-code/">realtime</a> became a breeze we can do optimistic updates with almost no effort.
The reason why you would do optimistic updates is that your application becomes amazingly fast and snappy! When implementing optimistic updates, the user will experience a native, mobile feeling.</p>

<p>Here you can find the npm package I’ve created for angular, called <a href="https://www.npmjs.com/package/ngrx-undo">ngrx-undo</a></p>

<p>Let me know if you enjoyed this article!</p>

	  ]]></description>
	</item>

	<item>
	  <title>How we made our app real-time in 6 lines of code</title>
	  <link>//How-we-made-our-app-real-time-in-6-lines-of-code/</link>
	  <author></author>
	  <pubDate>2016-09-11T00:00:00+00:00</pubDate>
	  <guid>//How-we-made-our-app-real-time-in-6-lines-of-code/</guid>
	  <description><![CDATA[
	     <p><a href="https://blog.kwintenp.com/">Kwinten Pisman</a> and me were working on a workshop this weekend with the focus on Reactive applications with <a href="http://angular.io">Angular 2</a>, <a href="https://github.com/ReactiveX/rxjs">RXJS</a> and <a href="https://github.com/ngrx">@ngrx</a>. Something that can’t miss in a reactive workshop are real-time updates. The application we are trying to make real-time is the <a href="http://winecellar.surge.sh">winecellar</a> app (you can register an account here if you want to test it).</p>

<p>To make this application real-time we changed some code in the node.js backend, but that’s out of scope for this post. 
The cool thing is, that we only needed <strong>6 lines of code</strong> to make the frontend completely real-time.</p>

<p>Here’s a small demo. Both computers are signed in with the same account. At the left screen, wines are being added and removed, and in the right screen you’ll see the changes happening real-time.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/realtimein6lines/realtimewinecellar.gif" alt="Winecellar app" /></p>

<h2 id="the-winecellar-app">The winecellar app</h2>

<p>The winecellar application is a simple application with only a few features, but we overengineered it on purpose to make it work for largescale applications.
You can find the open-source code of the winecellar project here: <a href="https://github.com/brechtbilliet/winecellar">frontend, (realtime branch)</a> and <a href="https://github.com/brechtbilliet/WineCellarBackend">backend</a>. Beware, the backend might be a little quick and dirty ;)</p>

<h3 id="technology-stack">Technology stack</h3>

<ul>
<li>Angular 2</li>
<li>RXJS</li>
<li>@ngrx/store as redux implementation</li>
<li>Typescript</li>
<li>We will use socket.io to make the real-time connection with the backend</li>
</ul>

<h3 id="features">features</h3>

<ul>
<li>Authentication</li>
<li>Add, update, remove wines</li>
<li>Searching in a public wine database (wine.com)</li>
<li>Filtering wines</li>
<li>Update the stock of wines</li>
<li>Setting ratings for wines</li>
</ul>

<p><img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/realtimein6lines/winecellar.png" alt="Winecellar app" /></p>

<h2 id="what-part-of-the-application-should-be-real-time">What part of the application should be real-time?</h2>

<ul>
<li>All the actions that will update the content in the database eventually should push notifications to all clients except the one sending them.</li>
<li>Even the filter should be real-time. (Eg. when filtering on "Chateau pomerol", and somebody adds that wine, we want to update our filtered results real-time)</li>
</ul>

<p>But why did we made something like that real-time? Actually, <strong>just because we can</strong>! It doesn’t really make sense that a user is logged in twice right? We did it for the purpose of the workshop.</p>

<h2 id="how-did-we-manage-to-make-it-real-time">How did we manage to make it real-time?</h2>

<p>First, let me give you a little bit of information about how the winecellar really works.</p>

<p>Like said before we use @ngrx/store as our redux implementation. It is a redux library that we use to maintain the state of our application. Basically, you can see it as a client-side store of all our wines and other state. We use that particular store as a single-source-of-truth. We will send actions towards that store which will update the state with pure functions called reducers.</p>

<p>In the following scheme you can see the unidirectional dataflow of redux: The view sends actions to the store which will update the state and then update the view.
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/realtimein6lines/redux.png" alt="Redux" /></p>

<p>Let’s say that we want to add a wine. when we add a wine, we send a XHR request to the backend and send an action to the store, like you can see in the snippet below. That is already how to wine application works</p>

<pre><code class="language-typescript">add(wine: Wine): void {
    this.http.post(`${API_URL}/wines`, wine, this.authorizedHttpOptions())
        .map((res: Response) =&gt; res.json())
    	.subscribe(resp =&gt;
    		this.store.dispatch({type: DATA_WINES_ADD, payload: {wine:resp}})
		);
}
</code></pre>

<p>This doesn’t have anything to do with real-time, right?! You are right, it doesn’t… But what if our backend can send Redux actions as well? If the backend can push redux actions to the frontend, then we can make it real-time with very little effort.</p>

<p>For every REST call where something in the database gets updated, we can send a redux action to all the clients which are logged in with the same username (except for ourselves)</p>

<p><strong>These are the 6 lines of code, that we need to make our frontend 100% real-time.</strong></p>

<pre><code class="language-typescript">import * as io from "socket.io-client";
// connect with socket.io and listen to redux actions
connect(): void {
    this.store.select(state =&gt; state.data.authentication.jwtToken)
    	.take(1).subscribe((token: string) =&gt; {
	        let socket = io(BACKEND, {query: "jwttoken=" + token});
	        socket.on("UPDATE_REDUX", action =&gt; this.store.dispatch(action));
    });
}
</code></pre>

<p>This is a simplified example of what happens on the backend when we add a wine, for instance.</p>

<pre><code class="language-typescript">@Post("/")
public post(@Req()req: Request, @Res() res: Response): void {
    let userId = handleAuth(req, res);
    new Wine(req.body).save((error, response) =&gt; {
        ...
        // emit a socket.io event to the client
        // which contains the redux action
        this.pushToClient(userId, req, {type: DATA_WINES_ADD, payload: {wine: response}});
        // return the new user
        res.send(response);
    });
}
</code></pre>

<h2 id="check-the-devtools">Check the devtools</h2>
<p>In The devtools below you’ll see the actions being dispatched during the lifecycle of the application. These actions can be triggered manually or real-time. Be sure to check them out at <a href="https://github.com/ngrx/store-devtools">https://github.com/ngrx/store-devtools</a>
<img src="https://raw.githubusercontent.com/brechtbilliet/brechtbilliet.github.io/master/_posts/realtimein6lines/winecellar_devtools.png" alt="Winecellar devtools" /></p>

<h2 id="conclusion">Conclusion</h2>

<p>The data that is managed by redux can be easily made real-time by making the backend dispatch redux actions to the frontend. 
That way, we can make our application real-time in matter of minutes.
If you want to learn more about these technologies: Be sure to checkout our workshop at <a href="http://ng-be.org">ngbe</a>.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Modals in Angular 2</title>
	  <link>//Modals-in-angular2/</link>
	  <author></author>
	  <pubDate>2016-08-24T00:00:00+00:00</pubDate>
	  <guid>//Modals-in-angular2/</guid>
	  <description><![CDATA[
	     <p><strong>Updated at 3 september 2016 (RC.6 compliant)</strong></p>

<p>Since one of my late New Year’s resolutions is blogging, behold my very first blogpost.
For a customer of mine I had to implement modal-dialog functionality in Angular 2.
As most developers would do in this scenario, I crawled the web searching for existing solutions.</p>

<p>Since Angular 2 has made some big breaking changes in its latest release candidates, most of these solutions were deprecated. The ones that weren’t deprecated weren’t stable enough and/or very bloated.</p>

<p>What I needed was actually very simple… I just needed a service that would open modals in Angular 2 and I only needed a few features:</p>
<ul>
<li>Multiple modals that could be placed above each other</li>
<li>Custom modals</li>
<li>The ability to destroy modals inside and outside the custom modal-component</li>
</ul>

<p><strong>Note:</strong> I’m using bootstrap as css framework so I don’t have to worry about the styling.</p>

<p>What I needed was a simple service where I could pass a component that would get rendered on the page, without memory leaks of course. Basically, I needed something like this:</p>

<pre><code class="language-typescript">
// this was possible in RC.5
this.modalService.create(MyCustomModalComponent, {foo: "bar"});


// this is what we need to do in RC.6
this.modalService.create(MyModule, MyCustomModalComponent, {foo: "bar"});

</code></pre>

<p>Since I didn’t found any viable solutions, I decided to write it myself.</p>

<p>Writing this piece of functionality myself, actually made me realise a few things:</p>
<ul>
<li>It wasn't difficult to write this functionality on my own</li>
<li>It was way more flexible than the solutions I found on the internet</li>
<li>It wasn't bloated at all</li>
<li>I wrote very few lines of code</li>
<li><strong>We use too much dependencies from the net</strong></li>
</ul>

<p>Don’t get me wrong, I don’t think we should reinvent the wheel everytime. I’m just saying that sometimes it’s better to write something your self, when it doesn’t cost you to much effort and saves you a lot of bloat.</p>

<p>The thing about a lot of open-source libraries is they want to make everybody happy, which mostly comes with a lot of bloat and features you don’t really need. And…, with a big codebase, comes a big issuelist…</p>

<p><strong>Enough about that, let’s see how I implemented my requirements with very little code…</strong></p>

<h2 id="a-brief-overview-of-the-flow">A brief overview of the flow</h2>
<p>First of all the modal-placeholder will register the Injector and ViewContainerRef (see later) to the UserModalService. At that time we can create modals using the UserModalService. These modals will be rendered into the modal-placeholder.</p>

<p><img src="https://github.com/brechtbilliet/brechtbilliet.github.io/raw/master/_posts/angular2modal.png" alt="Image of Angular 2 modal scheme" /></p>

<h2 id="the-modal-placeholder">The modal placeholder</h2>

<p>In Angular 2, you can not just compile stuff to the DOM, you need a placeholder.
That’s why I created a <strong>modal-placeholder</strong>, that I can use like this. This will be the placeholder where our modals will be rendered in.</p>

<pre><code class="language-typescript">@Component({
    selector: "application",
    template: `    
       ...
       &lt;modal-placeholder&gt;&lt;/modal-placeholder&gt;
       ...
`
})
export class ApplicationContainer {
	...
}
</code></pre>

<p><strong>Let’s look at the implementation</strong></p>

<p>The modal-placeholder has 3 goals:</p>
<ul>
<li>Create a placeholder (see the # symbol)</li>
<li>It should register that placeholder to a service where we can render modals into it (see ViewContainerRef)</li>
<li>It should register the injector to that service. Our modals will need DI as well...</li>
</ul>

<pre><code class="language-typescript">@Component({
    selector: "modal-placeholder",
    template: `&lt;div #modalplaceholder&gt;&lt;/div&gt;`
})
export class ModalPlaceholderComponent implements OnInit {
    @ViewChild("modalplaceholder", {read: ViewContainerRef}) 
    	viewContainerRef;

    constructor(
    	private modalService: ModalService, 
    	private injector: Injector) {
    }
    ngOnInit(): void {
        this.modalService.registerViewContainerRef(this.viewContainerRef);
        this.modalService.registerInjector(this.injector);
    }
}
</code></pre>
<p>As you can see above the ViewContainerRef holds a reference to the #modalplaceholder</p>

<h2 id="the-modal-service">The modal service</h2>
<p>This is the service that will dynamically generate custom components.</p>

<pre><code class="language-typescript">export class ModalService {
    // here we hold our placeholder
    private vcRef: ViewContainerRef; 
    // here we hold our injector
    private injector: Injector; 
    // we can use this to determine z-index of multiple modals
    public activeInstances: number = 0;
    
    constructor(private compiler: Compiler) {
    }

    registerViewContainerRef(vcRef: ViewContainerRef): void {
        this.vcRef = vcRef;
    }

    registerInjector(injector: Injector): void {
        this.injector = injector;
    }

	// update: as of rc6 we have to pass the module as well
    create&lt;T&gt;(module: any, component: any, parameters?: Object):
     	Observable&lt;ComponentRef&lt;T&gt;&gt; {
     	// we return a stream so we can  access the componentref
        let componentRef$ = new ReplaySubject(); 
        // compile the component based on its type and
        // create a component factory
        this.compiler.compileModuleAndAllComponentsAsync(module)
            .then(factory =&gt; {
            	// look for the componentfactory in the modulefactory
             	let componentFactory = factory.componentFactories
             		.filter(item =&gt; item.componentType === component)[0];
            	// the injector will be needed for DI in 
            	// the custom component
                const childInjector = ReflectiveInjector
                	.resolveAndCreate([], this.injector);
            	// create the actual component
                let componentRef = this.vcRef
                	.createComponent(componentFactory, 0, childInjector);
                // pass the @Input parameters to the instance
                Object.assign(componentRef.instance, parameters); 
                this.activeInstances ++;
                // add a destroy method to the modal instance
                componentRef.instance["destroy"] = () =&gt; {
                    this.activeInstances --;
                    // this will destroy the component
                    componentRef.destroy(); 
                };
                // the component is rendered into the ViewContainerRef
                // so we can update and complete the stream
                componentRef$.next(componentRef);
                componentRef$.complete();
            });
        return componentRef$;
    }
}
</code></pre>

<h2 id="the-custom-modal">The Custom modal</h2>

<p>As we saw above, every modal component will have a destroy method. That method is dynamically added (see logic above) to the instance of the modalcomponent. This will call the <strong>componentRef.destroy()</strong> behind the scenes which will safely destroy the component. I also found it convenient to have a closeModal function on the modal as well. Therefore every custom modal component we create should inherit this class:</p>

<pre><code class="language-typescript">export class ModalContainer {
    destroy: Function;
    closeModal(): void {
        this.destroy();
    }
}
</code></pre>

<p>This means, a custom modal could look like this: (ideally you could also create a generic modal component)</p>

<pre><code class="language-typescript">@Component({
	selector: "my-custom-modal",
	template: `
	&lt;div modal="" class="modal fade in"&gt;
		&lt;div class="modal-dialog"&gt;
			&lt;div class="modal-content"&gt;
				 &lt;button type="button" class="close" 
				 	(click)="closeModal()"&gt;×&lt;/button&gt;
				...
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/div&gt;
	&lt;div class="modal-backdrop fade in"&gt;&lt;/div&gt;
`
})
export class MyCustomModalComponent extends ModalContainer {
	@Input() foo;
	onSave(): Function;
	constructor(){
		super();
	}
	// the closeModal function will be available 
	// on the ModalContainer parent class
}
</code></pre>

<p>I love typescript decorators, and I didn’t want to inherit this ModalContainer everytime.
I wanted to create modal components like this:</p>

<pre><code class="language-typescript">@Component({
	selector: "my-custom-modal",
	template: `
	...
`
})
@Modal() // this decorator is all it takes
export class MyCustomComponent {
	@Input() foo;
	onSave(): Function;
}
</code></pre>

<p>This is basically the same thing as the inheritance example above, but much cleaner right?</p>

<p>Here’s the code for the custom decorator: (How easy is that?!)</p>

<pre><code class="language-typescript">export function Modal() {
    return function (target) {
        Object.assign(target.prototype,  ModalContainer.prototype);
    };
}
</code></pre>

<p>Ok, so what we have now is:</p>
<ul>
<li>modal-placeholder</li>
<li>modal-service</li>
<li>Modal container class with destroy delegation</li>
<li>modal-decorator to make the inheritance cleaner</li>
</ul>

<p>And… that’s it folks. That’s the only code I had to write (cleaned up a bit but still…)
It’s flexible, maintainable and easy to use… Let me show you…</p>

<h2 id="how-to-use-it">How to use it</h2>

<p>I want to create a modal of Type “MyCustomComponent”, pass it the property foo (@input) and pass a callback for the onSave function.</p>

<p><strong>Update: Since RC.6 we have to pass the module as well</strong></p>

<pre><code class="language-typescript">this.modalService.create&lt;MyCustomComponent&gt;(MyModule, MyCustomComponent, 
{ 
	foo: "bar", 
	onSave: () =&gt; alert('save me')
});
</code></pre>

<p>But wait? What if we want to destroy it outside of the component, you said you needed control over de lifetime of the component right?</p>

<p>That’s why the create function returns an observable that contains the componentRef, which has a destroy function.</p>

<pre><code class="language-typescript">this.modalService.create&lt;MyCustomComponent&gt;(MyModule, MyCustomComponent, 
	{ 
		foo: "bar", 
		onSave: () =&gt; alert('save me')
	})
	.subscribe((ref: ComponentRef&lt;MyCustomComponent&gt;) =&gt; {
		//destroy after 1 second
		setTimeout(() =&gt; ref.destroy(), 1000);
	});
</code></pre>

<h2 id="aot">AOT</h2>

<p><a href="http://blog.mgechev.com/2016/08/14/ahead-of-time-compilation-angular-offline-precompilation/">Ahead-time-compilation</a> in angular2 breaks this pattern (because the compiler will not be available in production in that scenario). For AOT to work you just need to use the generated factory and update the modalservice like below.</p>

<pre><code class="language-typescript">createFromFactory&lt;T&gt;(componentFactory: ComponentFactory&lt;T&gt;, 
	parameters?: Object): Observable&lt;ComponentRef&lt;T&gt;&gt; {
    let componentRef$ = new ReplaySubject();
    const childInjector = ReflectiveInjector.resolveAndCreate([], this.injector);
    let componentRef = this.vcRef.createComponent(componentFactory, 0, childInjector);
    // pass the @Input parameters to the instance
    Object.assign(componentRef.instance, parameters); 
    this.activeInstances++;
    componentRef.instance["destroy"] = () =&gt; {
        this.activeInstances--;
        componentRef.destroy();
    };
    componentRef$.next(componentRef);
    componentRef$.complete();
    return componentRef$.asObservable();
}

// you can call it like that
this.modalService.createFromFactory(myCustomModalNgFactory);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>With very little code I created a flexible way to create custom modal’s. Don’t <strong>always</strong> blindly rely on open source solutions. Think about the complexity and flexibility first.</p>

<p>Thanks for reading! I Hope you enjoyed it</p>

<h2 id="plunk">Plunk</h2>

<p><a href="https://plnkr.co/edit/0c2YuGt7n7Fti0uup6Gs?p=info">Checkout this plunk I’ve created</a></p>

	  ]]></description>
	</item>


</channel>
</rss>
