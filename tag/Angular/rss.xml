<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.strongbrew.io</title>
   
   <link></link>
   <description></description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>How share() can reduce network requests</title>
	  <link>//how-share()-can-reduce-network-requests</link>
	  <author></author>
	  <pubDate>2016-12-20T00:00:00+00:00</pubDate>
	  <guid>//how-share()-can-reduce-network-requests</guid>
	  <description><![CDATA[
	     <p>As you hopefully all know, observables you get back from the Angular 2 Http service are cold. A cold observable only starts when you subscribe to to it and is unicast (for every subscription to the Http observable, a network call is triggered).</p>

<p><strong>Note:</strong> If you want to dive deeper into hot vs cold observables, Christoph Burgdorf from Thoughtram wrote <a href="http://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html" target="_blank">an awesome article </a> on the subject (Rx pun intended :)).</p>

<h4 id="project-setup">Project setup</h4>

<p>To demonstrate how the <code>share()</code> operator can reduce our number of network calls, I’ve created a demo application (code available on <a href="https://github.com/KwintenP/save-netwerk-requests-with-share" target="_blank">Github</a>). The setup looks like this:</p>

<p><img src="https://www.dropbox.com/s/d87po1zbp2ri11u/Screenshot%202016-12-15%2020.08.33.png?raw=1" alt="setup" /></p>

<p>As you can see, we have an app component, which is smart, and three dumb components. During startup, the app component will randomly fetch one of the Star Wars characters by calling the StarWarsService.</p>

<pre><code class="language-typescript">// app.component.ts
this.character$ =
     this.starWarsService.getCharacter(this.generateNumber());
</code></pre>

<p>The StarWarsService uses Angular’s Http and returns a character from the series using the swapi.co API.</p>

<pre><code class="language-typescript">// star-wars.service.ts
public getCharacter(id: number): Observable&lt; StarWarsCharacter &gt; {
    return this.http.get('https://swapi.co/api/people/' + id)
      .map((response: Response) =&gt; response.json());
}
</code></pre>

<p>The app component creates three new observables by mapping the <code>character$</code> source observable.</p>

<pre><code class="language-typescript">// app.component.ts
this.name$ = this.character$.map(character =&gt; character.name);
this.birthDate$ = this.character$.map(character =&gt; character.birth_year);
this.gender$ = this.character$.map(character =&gt; character.gender);
</code></pre>

<p>The data is passed to the dumb components using the <code>async</code> pipe.</p>

<pre><code class="language-html">&lt;app-character-name [name]="name$ | async"&gt;
&lt;/app-character-name&gt;
&lt;app-character-birthdate [birthDate]="birthDate$ | async"&gt;
&lt;/app-character-birthdate&gt;

&lt;button type="button" (click)="toggleEnabled()"&gt;
     Enable gender component
&lt;/button&gt;
&lt;app-character-gender *ngIf="enabled" [gender]="gender$ | async"&gt;
&lt;/app-character-gender&gt;
</code></pre>

<p>As you can see in the snippet above, the gender component is only rendered <strong>after</strong> the button has been clicked. This way we can simulate a ‘delayed subscription’. We’ll see why this is important in a second.</p>

<h4 id="potential-pitfall">Potential pitfall</h4>
<p>If we run this code, everything works perfectly. But if we look at the network tab, we can see some strange behaviour.</p>

<p><img src="https://www.dropbox.com/s/j5etmgqz668v4wp/Dec-15-2016%2020-00-10.gif?raw=1" alt="setup" /></p>

<p>When the page is refreshed, we already see two calls to the backend. If we click the button to enable the gender component, we see another request being send. Why do we see multiple backend requests if we’re only asking for one <code>character$</code>?</p>

<p>The reason is simple. The <code>character$</code> is a <strong>cold observable</strong>. If you subscribe to a cold http observable twice, you’ll have two backend requests.
We map this <code>character$</code> or source observable using the <code>map</code> operator to three different observables. Every subscription to one of these three observables (which is done by the async pipe), is basically the same as subscribing to the <code>character$</code> observable directly. And because the <code>character$</code> observable is a cold observable, you see multiple requests.
The problem with this is that the underlying subscription to the source observable is <strong>not shared</strong>.</p>

<h4 id="how-can-we-fix-this-kind-of">How can we fix this (kind of)</h4>

<p>Let’s change the observable that the StarWarsService returns like this:</p>

<pre><code class="language-typescript">return this.http.get('https://swapi.co/api/people/' + id)
      .map((response: Response) =&gt; response.json())
      .share();
</code></pre>

<p>We added the <code>share()</code> operator. This is an alias for doing <code>publish().refCount()</code>. This will make the <code>character$</code> a hot observable that starts emitting events as soon as the first one subscribes. The <code>character$</code> observable will be a ‘shared’ one. Let’s first see what this means and explain afterwards:</p>

<p><img src="https://www.dropbox.com/s/o3i03kudmutt1gk/Dec-15-2016%2019-57-47.gif?raw=1" alt="setup" /></p>

<p>Now we can see that, on the initial page load, there is only one request. That’s because the <code>share()</code> operator will share the underlying subscription between its listeners. As soon as the first one subscribes, it will listen to the Http observable and thus trigger one backend request. Everybody else who starts listening afterwards, will get the same result. Hence we only see a single request to the swapi.co API.</p>

<p>But, when I click on the button to enable the gender component, we can see that a second request is triggered. This means our <code>share()</code> operator doesn’t help us entirely. It turns out that with <code>share()</code>, if the source observable completes, the underlying subscription is gone as well. So when the gender component gets rendered, the original request is long finished and completed. For every new subscription after this completion, in our case via the <code>gender$</code> observable, the <code>share()</code> operator will start a new backend request.</p>

<p>This can perfectly be expected behaviour, if you want it. In some cases though, you don’t.</p>

<h4 id="publishreplay-to-the-rescue">publishReplay to the rescue</h4>

<p>Let’s change the observable from the StarWarsService one more time:</p>

<pre><code class="language-typescript">let obs$: ConnectableObservable&lt;StarWarsCharacter&gt; =
     this.http.get('https://swapi.co/api/people/' + id)
         .map((response: Response) =&gt; response.json())
         .publishReplay();
obs$.connect();
return obs$;
</code></pre>

<p>I removed the <code>share()</code> operator and used <code>publishReplay()</code> instead. This will return an observable that will subscribe to the source observable as soon as you <code>connect()</code> it. In our case, this needs to happen immediately, so I call it before returning.
Let’s see what this does:</p>

<p><img src="https://www.dropbox.com/s/5j4381vj8439dbb/Dec-15-2016%2019-55-20.gif?raw=1" alt="setup" /></p>

<p>Alright! Now we only have one request at startup time and we do not have a new one when we render the gender component. The <code>publishReplay()</code> operator doesn’t care if the Http observable completes or not. For every new subscription, it will just return the previous result.</p>

<h4 id="conclusion">Conclusion</h4>

<ul>
  <li>If your source observable ‘splits’ into multiple observables, using the <code>share()</code> operator will reduce network requests.</li>
  <li>If you have subscriptions which are delayed due to delayed rendering, you might want to use the <code>publishReplay()</code> operator to avoid extra requests.</li>
</ul>

<p><strong>NOTE:</strong> Thanks to <a href="https://twitter.com/juristr">@juristr</a> for the review!</p>


	  ]]></description>
	</item>

	<item>
	  <title>How the hell does zone.js really work?</title>
	  <link>//how-the-hell-do-zones-really-work</link>
	  <author></author>
	  <pubDate>2016-06-09T00:00:00+00:00</pubDate>
	  <guid>//how-the-hell-do-zones-really-work</guid>
	  <description><![CDATA[
	     <p>If you’ve read about Angular 2 change detection, you will probably have heard about zones. Zones is a feature that was ported from Dart and is used internally by Angular 2 to determine if a change detection cycle should be triggered.</p>

<p>If you go to the <a href="https://github.com/angular/zone.js/" target="_blank">github</a> page of zone.js, you can find the following definition of a Zone:</p>

<blockquote>
  <p>A Zone is an execution context that persists across async tasks. You can think of it as thread-local storage for JavaScript VMs.</p>
</blockquote>

<p>If you’re like me, this will probably not make too much sense the first time you read it. To better understand what this means, I recommend watching this talk by Brian Ford <a href="https://www.youtube.com/watch?v=3IqtmUscE_U" target="_blank">at ngConf 2014</a> and read this post by thoughtram on <a href="http://blog.thoughtram.io/angular/2016/01/22/understanding-zones.html" target="_blank">understanding zones</a>.
However, even after watching the talk and reading the blogpost, I was still intrigued to find out how this actually works. How can zone.js monkey-patch browser events and how do the examples provided on their github page really work. The purpose of this blogpost is to share what I’ve learned during my discovery.</p>

<h5 id="how-are-events-monkey-patched-and-what-does-that-even-mean">How are events monkey-patched and what does that even mean?</h5>
<p>To see how events are monkey-patched, I decided to look into the source code. The following is a simplified conceptual snippet of what zone.js does at startup time.</p>

<pre><code class="language-typescript">function zoneAwareAddEventListener() {...}
function zoneAwareRemoveEventListener() {...}
function zoneAwarePromise() {...}
function patchTimeout() {...}
window.prototype.addEventListener = zoneAwareAddEventListener;
window.prototype.removeEventListener = zoneAwareRemoveEventListener;
window.prototype.promise = zoneAwarePromise;
window.prototype.setTimeout = patchTimeout;
</code></pre>
<p><strong>NOTE:</strong> zone.js patches even more events which I omitted since the concept is the same.</p>

<p>It turns out, zone.js overrides some of the functions on the window prototype and replaces the defaults with a proxy. This means that every event scheduled or every promise created after loading the file, will be wrapped in the proxy. This concept is called monkey-patching.</p>

<h5 id="time-to-explain-by-example">Time to explain by example</h5>
<p>Lets take a look at the first example from the readme of the zone.js github repository (Here’s the <a href="http://plnkr.co/edit/Ul44DohpdBfMKjgssspw?p=preview" target="_blank">plnkr</a> you can play around with).</p>

<pre><code class="language-typescript">//load zone.js
Zone.current.fork({}).run(function () {
    Zone.current.inTheZone = true;

    setTimeout(function () {
        console.log('in the zone: ' + !!Zone.current.inTheZone);
    }, 0);
});

console.log('in the zone: ' + !!Zone.current.inTheZone);
</code></pre>

<p>If you were to execute this, you’d get the following result:</p>

<pre><code class="language-typescript">'in the zone: false'
'in the zone: true'
</code></pre>

<p>Normally, you’d expect the result of both statements to be true since we’re logging the same property in both places.</p>

<p>To understand how this works, we need to zoom in on some parts of the snippet.</p>

<h5 id="creating-and-running-something-in-a-zone">Creating and running something in a Zone</h5>
<pre><code class="language-typescript">Zone.current.fork({}).run( .... );
</code></pre>
<p>When zone.js is loaded, it creates a global property which you can use to access the root Zone. In this example, a Zone is created by forking the root Zone via the <code>Zone.current</code> property. We call the run function on the created object to run something <strong>inside this Zone</strong>.</p>

<p><img src="http://www.jacquitalbot.com/wp-content/uploads/2013/11/in-the-zone.jpg" /></p>

<h5 id="the-function-executed-in-the-zone">The function executed in the Zone</h5>
<p>Next we look at the function that is run inside the Zone.</p>

<pre><code class="language-typescript">....
Zone.current.inTheZone = true;

setTimeout(function () {
        console.log('in the zone: ' + !!Zone.current.inTheZone);
    }, 0);
....
</code></pre>

<p>It first attaches a boolean to the <code>Zone.current</code> property. It then sets up a timer to log the property after the call stack has been cleared (if you do not know what this means, I suggest looking at the following <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank">talk</a>).</p>
<h5 id="the-log-statement-outside-of-the-zone">The log statement outside of the Zone</h5>
<p>Lastly, the same statement is logged <strong>outside of the zone</strong>.</p>

<pre><code class="language-typescript">....
console.log('in the zone: ' + !!Zone.current.inTheZone);
</code></pre>

<p>We again point to the same <code>Zone.current</code> property. How could this not log the same result if we’re pointing to the same property in both log statements?</p>

<h5 id="zone-setup-and-teardown">Zone setup and teardown</h5>
<p>Every time something is run <strong>inside a Zone</strong> or <strong>a monkey-patched event is triggered</strong>, the Zone or the proxy <strong>sets up the Zone</strong> before executing the function or callbacks. The proxy is able to setup the Zone since it holds <strong>a reference to the Zone in which it was created</strong>.
During setup, the state linked to this specific Zone is restored so that even timeouts, event listener, … are executed like they were executed immediately. You could think of a Zone as being an <strong>execution context that persists across async tasks</strong>, as the definition states.</p>

<p>To further clarify, take a look at the next snippet. I re-arranged the code in the way it is executed and added zone setup and teardown points. Look at the comments for more information.</p>

<pre><code class="language-typescript">// load zone.js. As stated before,
// this will monkey-patch all browser events.

Zone.current.fork({}).run(function () {
    // SETUP ZONE
    // trigger: A call to the run function is made. This will first
    //          setup the zone before executing the function param.
    // actions:
    //      - Zone.current property is set to the Zone
    //        in which the function is executed. In this case, it's
    //        the one we creating by forking the root Zone. Let's
    //        call it exampleZone from this point onwards.
    //      - Zone lifecycle hooks are called (we'll get back
    //        to that later).

    // a boolean is attached to the Zone.current property. Due
    // to the zone setup, this points to the exampleZone.
    Zone.current.inTheZone = true;

    // a timeout is registered. This isn't the 'default' timeout
    // since these are monkey-patched. So here, we are actually
    // setting up the proxy. What's important to remember is that
    // this proxy will hold a reference to the Zone in which it
    // was created, in this case the 'exampleZone'. This will be
    // used later.
    setTimeout(
       ...., 0);

    // TEARDOWN ZONE
    // trigger: The function that was to be executed
    //          inside the Zone has ended.
    // actions:
    //      - Zone.current property is reset to the root Zone
    //      - Zone lifecycle hooks are called
});

// Log statement. The Zone.current property is currently
// pointing to the root Zone. Since this does not know an
// 'inTheZone' property, this will log false.
console.log('in the zone: ' + !!Zone.current.inTheZone);

// The stack is cleared and the timer callback is executed

// SETUP ZONE
// trigger: The monkey-patched event is fired. The proxy wrapper
//          will trigger a Zone setup. Remember that the proxy
//          wrapper holds a reference to the Zone in which it
//          was created.
// actions:
//      - Zone.current property is set to the exampleZone (the
//        proxy holds a reference to the exampleZone)
//      - Zone lifecycle hooks are called
function () {
        // The exampleZone does contain the 'inTheZone'
        // property. So this will log true.
        console.log('in the zone: ' + !!Zone.current.inTheZone);
}
// TEARDOWN ZONE
    // trigger: The event callback has ended and the proxy
    //          does a Zone teardown.
    // actions:
    //      - Zone.current property is reset to the root Zone
    //      - Zone lifecycle hooks are called
</code></pre>

<p>Zone.js is able to setup and teardown the Zone when executing the timeout callback thanks to the monkey-patching of that event.
This should clear things up a bit!</p>

<h6 id="how-does-angular-2-leverage-zones">How does Angular 2 leverage zones</h6>
<p>I took a look inside the Angular 2 source code to determine how they leverage zones. Take a look at the next snippet:</p>

<pre><code class="language-typescript">....
new NgZoneImpl({
      trace: enableLongStackTrace,
      onEnter: () =&gt; {
        // console.log('ZONE.enter', this._nesting, this._isStable);
        this._nesting++;
        if (this._isStable) {
          this._isStable = false;
          this._onUnstable.emit(null);
        }
      },
      onLeave: () =&gt; {
        this._nesting--;
        // console.log('ZONE.leave', this._nesting, this._isStable);
        this._checkStable();
      },
      setMicrotask: (hasMicrotasks: boolean) =&gt; {
        this._hasPendingMicrotasks = hasMicrotasks;
        this._checkStable();
      },
      setMacrotask: (hasMacrotasks: boolean) =&gt;
            { this._hasPendingMacrotasks = hasMacrotasks; },
      onError: (error: NgZoneError) =&gt;
            this._onErrorEvents.emit(error)
    });
....
</code></pre>

<p>This is from the <a href="https://github.com/angular/angular/blob/master/packages/core/src/zone/ng_zone.ts" target="_blank">NgZone.ts</a> source file. Zone.js exposes lifecycle hooks. This is a listing of the events Angular 2 listens to. Since everything in Angular 2 is run in a single Zone, ngZone, Angular 2 can leverage this to determine when it should perform a Change Detection cycle based on those callbacks. This removes the need to manually call <code>$digest</code> like in Angular 1.
Pretty neat right!</p>

	  ]]></description>
	</item>


</channel>
</rss>
